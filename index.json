[{"categories":[],"content":"使用命令行工具解除UWP应用的网络隔离","date":"2022-07-27","objectID":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/","tags":["问题解决"],"title":"解除UWP应用的网络隔离","uri":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/"},{"categories":[],"content":"原文链接: https://zhuanlan.zhihu.com/p/55906778 ","date":"2022-07-27","objectID":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/:0:0","tags":["问题解决"],"title":"解除UWP应用的网络隔离","uri":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/"},{"categories":[],"content":"1 获取应用的SID 在注册表中找到应用的SID，注册表地址是： HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings Mappings 文件夹内的内容，就是所有 UWP 应用的对应的 SID。随便点击一个 SID 右边会显示应用名称。找到你要解除网络隔离的应用，复制它的 SID。 ","date":"2022-07-27","objectID":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/:1:0","tags":["问题解决"],"title":"解除UWP应用的网络隔离","uri":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/"},{"categories":[],"content":"2 解除应用隔离 使用 cmd 命令 CheckNetIsolation.exe loopbackexempt -a -p=%SID% ","date":"2022-07-27","objectID":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/:2:0","tags":["问题解决"],"title":"解除UWP应用的网络隔离","uri":"/2022/07/%E8%A7%A3%E9%99%A4uwp%E5%BA%94%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/"},{"categories":[],"content":"记录Git命令的常用操作","date":"2022-07-27","objectID":"/2022/07/git%E5%91%BD%E4%BB%A4/","tags":["git"],"title":"Git命令","uri":"/2022/07/git%E5%91%BD%E4%BB%A4/"},{"categories":[],"content":"1 git 配置 在 %UserProfile%\\.gitconfig文件中，配置用户信息和代理设置，如下 [user] email = email@email.dom name = username [http] proxy = http://127.0.0.1:7890 [https] proxy = http://127.0.0.1:7890 ","date":"2022-07-27","objectID":"/2022/07/git%E5%91%BD%E4%BB%A4/:1:0","tags":["git"],"title":"Git命令","uri":"/2022/07/git%E5%91%BD%E4%BB%A4/"},{"categories":[],"content":"2 和 github 连接 ","date":"2022-07-27","objectID":"/2022/07/git%E5%91%BD%E4%BB%A4/:2:0","tags":["git"],"title":"Git命令","uri":"/2022/07/git%E5%91%BD%E4%BB%A4/"},{"categories":[],"content":"2.1 密钥生成和相关配置 使用 ssh-keygen 生成密钥 在 %UserProfile%\\.ssh\\config 文件中添加配置，配置如下 登录 github 账号，在用户设置中，上传第一步生成的密钥 # github Host github HostName github.com AddKeysToAgent yes PreferredAuthentications publickey IdentityFile ~/.ssh/gitsshkey User username ","date":"2022-07-27","objectID":"/2022/07/git%E5%91%BD%E4%BB%A4/:2:1","tags":["git"],"title":"Git命令","uri":"/2022/07/git%E5%91%BD%E4%BB%A4/"},{"categories":[],"content":"2.2 建立连接 在github新建仓库 example 本地仓库初始化，并连接 git init git add . git commit -m 'init' # 如有必要修改分支名称为 main git branch -m main # 修改远程仓库名 git remote add origin git@github.com:username/example.git # -f 为强制推送 git push -f -u origin main # 从远端拉取到本地 git pull origin main ","date":"2022-07-27","objectID":"/2022/07/git%E5%91%BD%E4%BB%A4/:2:2","tags":["git"],"title":"Git命令","uri":"/2022/07/git%E5%91%BD%E4%BB%A4/"},{"categories":[],"content":"一些好用的工具、或项目合集","date":"2022-07-26","objectID":"/2022/07/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/","tags":["工具资源集合"],"title":"工具收集","uri":"/2022/07/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/"},{"categories":[],"content":" lux 视频下载工具，采用命令行方式 DownKyi 哔哩哔哩视频下载工具，具有界面 SMSBoom 基于python的短信轰炸程序 云萌win10激活 一款windows10数字权利激活工具 ","date":"2022-07-26","objectID":"/2022/07/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:0:0","tags":["工具资源集合"],"title":"工具收集","uri":"/2022/07/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/"},{"categories":[],"content":"记录spaceclaim命令行如何传入参数，以及脚本中如何获取参数","date":"2022-07-26","objectID":"/2022/07/spaceclaim%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5/","tags":["SpaceClaim","软件脚本编程"],"title":"Spaceclaim命令行参数传入","uri":"/2022/07/spaceclaim%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5/"},{"categories":[],"content":"1 命令行参数帮助信息 cmd 窗口执行 spaceclaim /? 弹出帮助文档 帮助文档实际上位于路径 %UserProfile%\\Documents\\SpaceClaimReports\\ 中 ","date":"2022-07-26","objectID":"/2022/07/spaceclaim%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5/:1:0","tags":["SpaceClaim","软件脚本编程"],"title":"Spaceclaim命令行参数传入","uri":"/2022/07/spaceclaim%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5/"},{"categories":[],"content":"2 传参常用命令 使用 /ScriptArgs 传入参数，参数之间用, 隔开 spaceclaim /RunScript=\"jou\\script.py\" /ScriptArgs=\"15,pas15\" /Headless=True /Splash=False /Welcome=False /ExitAfterScript=True 然后 python 脚本中使用 args[n] 来获取，类型为字符串 注意\r脚本路径是相对于 spaceclaim 的运行路径而言的 使用的是 Ansys 2020R1 对应的 spaceclaim 版本，api version: 18 ","date":"2022-07-26","objectID":"/2022/07/spaceclaim%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5/:2:0","tags":["SpaceClaim","软件脚本编程"],"title":"Spaceclaim命令行参数传入","uri":"/2022/07/spaceclaim%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5/"},{"categories":["机器学习"],"content":"奇异值分解和主成分分析的联系","date":"2020-06-03","objectID":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/","tags":["线性代数","机器学习","主成分分析","PCA"],"title":"奇异值分解和主成分分析","uri":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["机器学习"],"content":"1 矩阵乘法的几何意义 正交矩阵：可以理解为旋转，因为模不变 对角矩阵：维度伸缩（不为0的部分），维度压缩（为0的部分） ","date":"2020-06-03","objectID":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:1:0","tags":["线性代数","机器学习","主成分分析","PCA"],"title":"奇异值分解和主成分分析","uri":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["机器学习"],"content":"2 特征值分解和奇异值分解 特征值分解： $$A=U\\Sigma U^T$$ 奇异值分解： $$A=U\\Sigma V^T$$ ","date":"2020-06-03","objectID":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:2:0","tags":["线性代数","机器学习","主成分分析","PCA"],"title":"奇异值分解和主成分分析","uri":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["机器学习"],"content":"3 主成分分析 数据矩阵：$X$，维度 $m\\times n$，$m$ 是数据维度，$n$ 是数据样本数 目标：寻找一个矩阵 P，使得 $Y=PX$ 的协方差矩阵对角化（也就是找到源数据在新成分的作用下尽可能线性无关），$YY^T$ 对角化 对 $X$ 奇异值分解: $$X=U\\Sigma V^T$$ 可以找到 $P=U^T$，使得： $$Y= U^T X = \\Sigma V^T$$ $YY^T = \\Sigma\\Sigma^T$ 也可以从特征值分解的角度来理解： $$XX^T=P^T(YY^T)P$$ 由于 $YY^T$ 需要是一个对角矩阵，根据特征值分解可以求得 ","date":"2020-06-03","objectID":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:3:0","tags":["线性代数","机器学习","主成分分析","PCA"],"title":"奇异值分解和主成分分析","uri":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["机器学习"],"content":"降维 为了只取前 L 个主成分（也就是把原数据映射到 L 维的向量空间中），可以对 $U$ 取前 L 列 $U_L$，或者对 $\\Sigma$ 取前 L 行 $\\Sigma_L$，则： $$Y={U_L}^TX=\\Sigma_LV^T$$ ","date":"2020-06-03","objectID":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:3:1","tags":["线性代数","机器学习","主成分分析","PCA"],"title":"奇异值分解和主成分分析","uri":"/2020/06/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%92%8C%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["线性代数"],"content":"线性方程组的求解方法总结","date":"2020-06-03","objectID":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/","tags":["线性代数","线性方程组"],"title":"线性方程组求解","uri":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"},{"categories":["线性代数"],"content":"根据目前所学和所了解的情况，线性方程组的求解方法可以分为如下四种： ","date":"2020-06-03","objectID":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/:0:0","tags":["线性代数","线性方程组"],"title":"线性方程组求解","uri":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"},{"categories":["线性代数"],"content":"1 直接求解 包括如下几种： 直接对矩阵求逆 对矩阵进行分解（LU, QR, LQ, SVD 等)，然后进行求解。这利用了正交矩阵，对角矩阵，三角矩阵的一些优良特征进行求解。 ","date":"2020-06-03","objectID":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/:1:0","tags":["线性代数","线性方程组"],"title":"线性方程组求解","uri":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"},{"categories":["线性代数"],"content":"2 不动点迭代法 高斯-赛德尔迭代 雅可比迭代 SOR ","date":"2020-06-03","objectID":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/:2:0","tags":["线性代数","线性方程组"],"title":"线性方程组求解","uri":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"},{"categories":["线性代数"],"content":"3 共轭梯度法 CG, PCG 等，将原线性方程，转化为二次函数，原方程的解是二次函数的极值点。 ","date":"2020-06-03","objectID":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/:3:0","tags":["线性代数","线性方程组"],"title":"线性方程组求解","uri":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"},{"categories":["线性代数"],"content":"4 多重网格法 几何多重网格（GMG），代数多重网格（AMG）等，CFD 中有应用 ","date":"2020-06-03","objectID":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/:4:0","tags":["线性代数","线性方程组"],"title":"线性方程组求解","uri":"/2020/06/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"},{"categories":["GSL"],"content":"矩阵完全正交分解，和 GSL 完全正交分解","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"1 写在前面 若无特别说明，本篇代码均来自头文件 gsl_linalg.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:1:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"2 完全正交分解 完全正交分解可以看作是QR分解的推广，对于矩阵 $A$ ($M\\times N$)，有如下分解： $$A P=Q\\left(\\begin{array}{cc}R_{11} \u0026 0 \\ 0 \u0026 0\\end{array}\\right) Z^{T}$$ 其中： $P$：转置矩阵，$N\\times N$ $Q$：正交矩阵，$M\\times M$ $R_{11}$：上三角矩阵，$r\\times r, r=rank(A)$ $Z$：正交矩阵，$N\\times N$ 如果 $A$ 满秩，$R_{11}=R,Z=I$，也就是带列转置的 QR 分解 对于不满秩 $A$，其对应的最小二乘解 ($\\min_x|Ax-b|$) 不唯一，如果进一步加上条件 $\\min_x|x|$，利用完备正交解，可以得到 $x$ $$x=PZ\\left(\\begin{array}{c} R_{11}^{-1}c_1\\ 0\\end{array}\\right)$$ 其中 $c_1$ 是 $Q^Tb$ 的前 $r$ 个元素 以吉洪诺夫 (Tikhonov) 正则化的形式表述下列问题 $$\\min_x(|Ax-b|^2+\\lambda^2|x|^2)$$ 该问题的解为： $$x=PZ\\left(\\begin{array}{c} y_1\\ 0\\end{array}\\right)$$ 其中 $y_1$ 长度为 $r$，可以根据下列方程求出： $$\\left(\\begin{array}{c} R_{11}\\ \\lambda I_r\\end{array}\\right)y_1=\\left(\\begin{array}{c} c_1\\ 0\\end{array}\\right)$$ 该方程可以用 QR 分解方法求解 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:2:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"3 完全正交分解相关函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:3:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"完全正交分解 $A=QRZP^T$ $Q,Z$ 一部分存在 A 中，另一部分存在 tau_Q, tau_Z 中 $R_{11}$ 存在 A 中， rank 计算方式，参考：QR分解 work 为工作空间，长度为 $N$ int gsl_linalg_COD_decomp(gsl_matrix * A, gsl_vector * tau_Q, gsl_vector * tau_Z, gsl_permutation * p, size_t * rank, gsl_vector * work); int gsl_linalg_COD_decomp_e(gsl_matrix * A, gsl_vector * tau_Q, gsl_vector * tau_Z, gsl_permutation * p, double tol, size_t * rank, gsl_vector * work); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:3:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"计算带正则的最小二乘解 $\\min_x(|Ax-b|^2+|x|^2)$，当 $A$ 满秩时，不考虑正则项 int gsl_linalg_COD_lssolve (const gsl_matrix * QRZT, const gsl_vector * tau_Q, const gsl_vector * tau_Z, const gsl_permutation * perm, const size_t rank, const gsl_vector * b, gsl_vector * x, gsl_vector * residual); $\\min_x(|Ax-b|^2+\\lambda|x|^2)$ 工作空间矩阵 S 维度为 rank x rank，工作空间向量 work 维度为 rank int gsl_linalg_COD_lssolve2 (const double lambda, const gsl_matrix * QRZT, const gsl_vector * tau_Q, const gsl_vector * tau_Z, const gsl_permutation * perm, const size_t rank, const gsl_vector * b, gsl_vector * x, gsl_vector * residual, gsl_matrix * S, gsl_vector * work); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:3:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"解包 int gsl_linalg_COD_unpack(const gsl_matrix * QRZT, const gsl_vector * tau_Q, const gsl_vector * tau_Z, const size_t rank, gsl_matrix * Q, gsl_matrix * R, gsl_matrix * Z); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:3:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"计算 $AZ$ $A$ 必须为 $N$ 列，work 长度为 $N$ int gsl_linalg_COD_matZ(const gsl_matrix * QRZT, const gsl_vector * tau_Z, const size_t rank, gsl_matrix * A, gsl_vector * work); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/:3:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 5 — 完全正交分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05/"},{"categories":["GSL"],"content":"GSL LQ 分解","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"1 写在前面 关于 LQ 分解的背景知识介绍，参见：LQ分解，本篇只说明相关函数 若无特别说明，本篇代码均来自头文件 gsl_linalg.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:1:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"2 LQ 分解相关函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:2:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"LQ 分解 $A=LQ$ 分解得到 L Q, L 存放在 A 的下三角 (包含对角线) ，Q 分为两部分，分别存在 A 的上三角部分 (不包含对角线) 和向量 tau 中 int gsl_linalg_LQ_decomp (gsl_matrix * A, gsl_vector * tau); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:2:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"LQ 解包 int gsl_linalg_LQ_unpack (const gsl_matrix * LQ, const gsl_vector * tau, gsl_matrix * Q, gsl_matrix * L); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:2:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"求解线性方程组 $Ax=b$ ($A:M\\le N,A=LQ$) int gsl_linalg_LQ_lssolve(const gsl_matrix * LQ, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x, gsl_vector * residual); $x^TL=b^TQ^T$ int gsl_linalg_LQ_solve_T (const gsl_matrix * LQ, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x); int gsl_linalg_LQ_svx_T (const gsl_matrix * LQ, const gsl_vector * tau, gsl_vector * x); int gsl_linalg_LQ_LQsolve (gsl_matrix * Q, gsl_matrix * L, const gsl_vector * b, gsl_vector * x); $x^TA=b^T$($A:M\\le N,A=LQ$) 相当于超定方程的 LQ 解法 int gsl_linalg_LQ_lssolve_T (const gsl_matrix * LQ, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x, gsl_vector * residual); $x^TL=b^T$ int gsl_linalg_LQ_Lsolve_T (const gsl_matrix * LQ, const gsl_vector * b, gsl_vector * x); int gsl_linalg_LQ_Lsvx_T (const gsl_matrix * LQ, gsl_vector * x); int gsl_linalg_L_solve_T (const gsl_matrix * L, const gsl_vector * b, gsl_vector * x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:2:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"其他 $Q^Tv$ int gsl_linalg_LQ_QTvec(const gsl_matrix * LQ, const gsl_vector * tau, gsl_vector * v); $vQ$ int gsl_linalg_LQ_vecQ (const gsl_matrix * LQ, const gsl_vector * tau, gsl_vector * v); $vQ^T$ int gsl_linalg_LQ_vecQT (const gsl_matrix * LQ, const gsl_vector * tau, gsl_vector * v); $L^{’}Q^{’}=(L+vw^T)Q$ int gsl_linalg_LQ_update (gsl_matrix * Q, gsl_matrix * R, const gsl_vector * v, gsl_vector * w); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:2:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"3 参考 https://github.com/ludvigak/gsl/blob/master/linalg/lq.c ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/:3:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 4 — LQ 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"},{"categories":["GSL"],"content":"GSL QR 分解","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"1 写在前面 关于 QR 分解的背景知识介绍，参见：QR分解，本篇只说明相关函数 若无特别说明，本篇代码均来自头文件 gsl_linalg.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:1:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"2 QR 分解相关函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"QR 分解 $A=QR$ Householder 版: 将 A 分解为 Q R, Q 分别存储在矩阵 A 的下三角部分 ($v$) 和向量 tau ($\\tau$) 中，R 存储在矩阵 A 的上三角部分（含对角） 推荐此方法用于中小型矩阵，或用于 $M\u003cN$ 时 int gsl_linalg_QR_decomp (gsl_matrix * A, gsl_vector * tau); 递归版 (带 _r)： 将 A 分解为 Q R, Q 分别存储在矩阵 A 的下三角部分 ($V$) 和矩阵 T ($T$) 中，R 存储在矩阵 A 的上三角部分（含对角） int gsl_linalg_QR_decomp_r (gsl_matrix * A, gsl_matrix * T); 此方法要求 $M\\ge N$，并且该方法对于“高瘦”型矩阵 ($M\\gg N$) 表现更佳 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"QR 解包 根据 QR 和 tau (T) 得到矩阵 Q 和矩阵 R int gsl_linalg_QR_unpack(const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * Q, gsl_matrix * R); int gsl_linalg_QR_unpack_r(const gsl_matrix * QR, const gsl_matrix * T, gsl_matrix * Q, gsl_matrix * R); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"QR 求解线性方程组 根据 QR 分解得到的 QR 和 tau (或 T)，求解线性方程组 $Ax=b$ int gsl_linalg_QR_solve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x); int gsl_linalg_QR_solve_r (const gsl_matrix * QR, const gsl_matrix * T, const gsl_vector * b, gsl_vector * x); // 置换版本 int gsl_linalg_QR_svx (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * x); 求解 $Ax=b$ 的最小二乘解（使用欧几里得范数，$A(M\u003eN)$） Householder 版还输出残差向量 (residual) 递归版输出的向量 x 包含两个部分，x 的前 $N$ 个元素为解，后 $M-N$ 个元素的向量范数等于残差范数，递归版还需要一个向量工作空间 (work)，长度为 $N$ int gsl_linalg_QR_lssolve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x, gsl_vector * residual); int gsl_linalg_QR_lssolve_r (const gsl_matrix * QR, const gsl_matrix * T, const gsl_vector * b, gsl_vector * x, gsl_vector * work); 求解 $Rx=b$ 使用 QR 矩阵中的 R int gsl_linalg_QR_Rsolve (const gsl_matrix * QR, const gsl_vector * b, gsl_vector * x); int gsl_linalg_QR_Rsvx (const gsl_matrix * QR, gsl_vector * x); 直接使用 R (上三角矩阵) int gsl_linalg_R_solve (const gsl_matrix * R, const gsl_vector * b, gsl_vector * x); int gsl_linalg_R_svx (const gsl_matrix * R, gsl_vector * x); 求解 $Rx=Q^Tb$ int gsl_linalg_QR_QRsolve (gsl_matrix * Q, gsl_matrix * R, const gsl_vector * b, gsl_vector * x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"计算其他 计算 $Q^Tv$ 递归版需要一个向量工作空间，长度 $N$ int gsl_linalg_QR_QTvec(const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * v); int gsl_linalg_QR_QTvec_r(const gsl_matrix * QR, const gsl_matrix * T, gsl_vector * b, gsl_vector * work); 计算 $Qv$ int gsl_linalg_QR_Qvec (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * v); 计算 $Q^TB$，矩阵 $B$ 维度 ($M\\times K$) 递归版需要一个矩阵工作空间，维度为 $N\\times K$ int gsl_linalg_QR_QTmat(const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * A); int gsl_linalg_QR_QTmat_r(const gsl_matrix * QR, const gsl_matrix * T, gsl_matrix * B, gsl_matrix * work); QR 分解的秩 1 更新 $Q^{’} R^{’}=Q(R+wv^T)$ int gsl_linalg_QR_update (gsl_matrix * Q, gsl_matrix * R, gsl_vector * w, const gsl_vector * v); 计算 $R$ 的倒数范数 (使用 1 范数) $$\\frac{1}{|R|_1|R^{-1}|_1}$$ 向量工作空间维度为 $3N$ int gsl_linalg_QR_rcond(const gsl_matrix * QR, double * rcond, gsl_vector * work); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"特殊矩阵 QR 分解 背景相关知识参见：特殊矩阵的QR分解 将矩阵 $(S,A)^T$ QR 分解，得到矩阵 R, Y, T，矩阵 R 存在矩阵 S 中，矩阵 Y 存在 A 中 int gsl_linalg_QR_TR_decomp (gsl_matrix * S, gsl_matrix * A, gsl_matrix * T); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:5","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"带列转置的 QR 分解 $QRP^T$ 分解，norm 是一个向量工作空间，长度为 $N$ // 分解之后 Q 的 v 部分和 R 存在 A 中 int gsl_linalg_QRPT_decomp (gsl_matrix * A, gsl_vector * tau, gsl_permutation * p, int *signum, gsl_vector * norm); // 分解之后Q R 分别储在 q r 中 int gsl_linalg_QRPT_decomp2 (const gsl_matrix * A, gsl_matrix * q, gsl_matrix * r, gsl_vector * tau, gsl_permutation * p, int *signum, gsl_vector * norm); 利用 $QRP^T$ 分解求解 $Ax=b$ int gsl_linalg_QRPT_solve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x); int gsl_linalg_QRPT_svx (const gsl_matrix * QR, const gsl_vector * tau, const gsl_permutation * p, gsl_vector * x); 利用 $QRP^T$ 分解求 $Ax=b$ 的最小二乘解 ($A$ 满秩，$A(M\u003eN)$) int gsl_linalg_QRPT_lssolve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x, gsl_vector * residual); 利用 $QRP^T$ 分解求 $Ax=b$ 的最小二乘解 ($A$ 秩为 rank，$A(M\u003eN)$) int gsl_linalg_QRPT_lssolve2 (const gsl_matrix * QR, const gsl_vector * tau, const gsl_permutation * p, const gsl_vector * b, const size_t rank, gsl_vector * x, gsl_vector * residual); 求解 $RP^Tx=Q^Tb$ int gsl_linalg_QRPT_QRsolve (const gsl_matrix * Q, const gsl_matrix * R, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x); 求解 $RP^Tx=b$ int gsl_linalg_QRPT_Rsolve (const gsl_matrix * QR, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x); int gsl_linalg_QRPT_Rsvx (const gsl_matrix * QR, const gsl_permutation * p, gsl_vector * x); $QRP^T$ 分解的秩 1 更新 $$Q^{’}R^{’}=Q(R+wv^TP)$$ int gsl_linalg_QRPT_update (gsl_matrix * Q, gsl_matrix * R, const gsl_permutation * p, gsl_vector * u, const gsl_vector * v); $R$ 的倒数范数（使用 1 范数），向量工作空间 work 维度为 $3N$ $$\\frac{1}{|R|_1|R^{-1}|_1}$$ int gsl_linalg_QRPT_rcond(const gsl_matrix * QR, double * rcond, gsl_vector * work); 估计 $R$ 的秩，统计 $R$ 的对角元素绝对值大于 tol 的个数，如果 tol 为负，使用如下默认值： $$20(M+N)eps(max(|diag(R)|))$$ size_t gsl_linalg_QRPT_rank (const gsl_matrix * QR, const double tol); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/:2:6","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 3 — QR 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"},{"categories":["GSL"],"content":"GSL LU 分解","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"1 写在前面 关于 LU 分解的背景知识介绍，参见：LU分解，本篇只说明相关函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:1:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"2 LU 分解相关对象和函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:2:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"转置矩阵对象 转置矩阵对象存储着一列索引。第 $j$ 个数为 $k$ ，表示转置矩阵第 $j$ 列是相应单位矩阵的第 $k$ 列，定义如下： // gsl_permutation.h struct gsl_permutation_struct { size_t size; size_t *data; }; typedef struct gsl_permutation_struct gsl_permutation; ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:2:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"LU 分解函数 将矩阵 A 进行 LU 分解，然后得到转置矩阵 p，LU 矩阵储存在 A 中，signum 为 1 或 -1，代表交换的次数，奇数次为 -1，偶数次为 1 因为下三角（梯形）矩阵对角线为 1，不储存，A 刚好可以方向 LU // gsl_linalg.h int gsl_linalg_LU_decomp(gsl_matrix * A, gsl_permutation * p, int *signum); int gsl_linalg_complex_LU_decomp(gsl_matrix_complex * A, gsl_permutation * p, int *signum); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:2:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"LU 求解方程 solve版本：给 LU 矩阵，p 转置矩阵，向量 b，得到解向量 x svx版本: 给 LU 矩阵，p 转置矩阵，向量 b（就是 x），得到解向量 x，解向量存在 x 中，即 solve 的置换版本 refine 版本：应用迭代改进的办法求解 x，还需要给一个向量工作空间 work，长度为 x 的长度 // gsl_linalg.h int gsl_linalg_LU_solve (const gsl_matrix * LU, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x); int gsl_linalg_complex_LU_solve (const gsl_matrix_complex * LU, const gsl_permutation * p, const gsl_vector_complex * b, gsl_vector_complex * x); int gsl_linalg_LU_svx (const gsl_matrix * LU, const gsl_permutation * p, gsl_vector * x); int gsl_linalg_complex_LU_svx (const gsl_matrix_complex * LU, const gsl_permutation * p, gsl_vector_complex * x); int gsl_linalg_LU_refine (const gsl_matrix * A, const gsl_matrix * LU, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x, gsl_vector * work); int gsl_linalg_complex_LU_refine (const gsl_matrix_complex * A, const gsl_matrix_complex * LU, const gsl_permutation * p, const gsl_vector_complex * b, gsl_vector_complex * x, gsl_vector_complex * work); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:2:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"LU 求逆 类似地，分为无置换版本 (invert) 和置换版本 (invx)，无置换时，存在矩阵 inverse 中，有置换时，存在 LU 中 // gsl_linalg.h int gsl_linalg_LU_invert (const gsl_matrix * LU, const gsl_permutation * p, gsl_matrix * inverse); int gsl_linalg_complex_LU_invert (const gsl_matrix_complex * LU, const gsl_permutation * p, gsl_matrix_complex * inverse); int gsl_linalg_LU_invx (gsl_matrix * LU, const gsl_permutation * p); int gsl_linalg_complex_LU_invx (gsl_matrix_complex * LU, const gsl_permutation * p); 最好避免通过直接求逆的方法来求解线性方程组，因为线性方程组求解函数更有效率和更准确 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:2:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"LU 求行列式 求解 $\\det(A)$，需要给 LU 矩阵 // gsl_linalg.h double gsl_linalg_LU_det (gsl_matrix * LU, int signum); gsl_complex gsl_linalg_complex_LU_det (gsl_matrix_complex * LU, int signum); 求解 $\\ln(|\\det(A)|)$，需要给 LU 矩阵 // gsl_linalg.h double gsl_linalg_LU_lndet (gsl_matrix * LU); double gsl_linalg_complex_LU_lndet (gsl_matrix_complex * LU); 求解 $\\det(A)/|\\det(A)|$，需要给 LU 矩阵 // gsl_linalg.h int gsl_linalg_LU_sgndet (gsl_matrix * lu, int signum); gsl_complex gsl_linalg_complex_LU_sgndet (gsl_matrix_complex * LU, int signum); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/:2:5","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 2 — LU 分解","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"},{"categories":["GSL"],"content":"线性代数矩阵分解基本知识，LU 分解，QR 分解，LQ 分解","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"1 写在前面 本篇旨在对线性代数相关的背景知识做一些简要结论性说明，这样做的目的是为了更清楚的了解 GSL 线性代数部分的函数是在做什么，因此并不会进行推导性说明。 同时，本篇还对每个线性代数知识点提供一个说明对应 GSL 相关函数的链接页面，所以本篇还有对 GSL 线性代数部分的相关函数进行导航的功能。 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:1:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"2 LU 分解 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:2:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"相关符号 置换矩阵：$P$ 上三角 (梯形) 矩阵：$U$ 下三角 (梯形) 矩阵：$L$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:2:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"LU 分解 对于一般矩阵 $A(M\\times N)$，有如下分解： $$PA=LU$$ 其中：$P:M\\times M; L:M\\times \\min(M,N); U: \\min(M,N)\\times M$; $M\\ge N$ 时，$L$ 是下单位三角（梯形）矩阵 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:2:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"应用 求解线性方程组 $Ax=b$ 求逆 $A^{-1}$ 求行列式 $\\det(A)$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:2:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"相关函数说明 参见：LU 分解函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:2:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"3 QR 分解 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"相关符号 $Q$：正交矩阵 $R$：上三角（梯形）矩阵 $H$：Householder 矩阵 $v$：Householder 向量 $\\tau$：Householder 系数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"QR 分解 矩阵 $A$ ($M\\times N$) 可以分解为如下形式： $$A=QR$$ 其中：$Q:M\\times M;;;;R:M\\times N$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"应用 一般可以用来求超定方程 ($M\u003eN$) 的最小二乘解 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"QR 分解实施方式 这里说明两种，也是 GSL 当中实现的两种。 Householder 变化法 Householder 矩阵是一个正交矩阵，其作用在向量上是一个镜像变换，也就是说通过镜像变换可以将向量映射到坐标轴上，即将向量大部分元素置 0。可以通过多个 Householder 矩阵将矩阵 $A$ 变为上三角（梯形）矩阵 注意：对于此种方法在 GSL 中，$Q$ 矩阵并不是直接存储的，而是通过 Householder 公式转换的方式进行存储，公式如下： $$Q=H_k\\cdots H_2H_1$$ $$H_i=I-\\tau_iv_iv_i^T$$ $$v_i=(0,0,\\cdots,1,a_{i+1},a_{i+2},\\cdots)$$ 因此，在此种方式中， GSL 对 $Q$ 矩阵储存如下两个部分： 一个 $\\tau$ 向量，$(\\tau_1,\\tau_2,\\cdots,\\tau_k)$ 每个 $v_i$ 向量，并且只储存后面的 $a$ 部分 递归法（DGEQRF） 参考文献：Applying recursion to serial and parallel QR factorization leads to better performance 注意： 同样在此种方法中，$Q$ 也不是直接储存的，按照如下公式进行转换储存： $$Q=1-VTV^T$$ 其储存也分为如下两个部分： 储存 $V$，$V$ 的列向量就是 $v_i$，储存方式如同 Householder 变化法 储存矩阵 $T$，矩阵 $T$ 的对角向量就是 $\\tau$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"特殊矩阵的 QR 分解 $$\\left(\\begin{array}{l}S \\ A\\end{array}\\right)=Q R$$ $S$ 为 上三角矩阵，维度 $N\\times N$；$A$ 为稠密矩阵，维度 $M\\times N$ ，此时的 $Q$ 公式如下： $$Q=I-VTV^T$$ $$V=\\left(\\begin{array}{l}I \\ Y\\end{array}\\right)$$ 此时，其储存分为三部分： $T$ 储存 $Y$ 储存，$Y$ 也是稠密矩阵，维度和 $A$ 一样 $R$ 储存 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:5","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"带列转置的 QR 分解 $$AP=QR$$ $$A=QRP^T$$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:6","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"相关函数说明 参见：QR 分解函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:3:7","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"4 LQ 分解 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:4:0","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"相关符号 $L$: 下三角（梯形）矩阵 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:4:1","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"LQ 分解 $$A=LQ$$ 其中：$L:M\\times N;;;;Q:N\\times N$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:4:2","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"应用 LQ 分解一般可以用来求亚定方程 ($M\\le N$) 的最小范数解 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:4:3","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"相关函数 参见：LQ 分解函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/:4:4","tags":["GSL","线性代数"],"title":"GSL 系列 6 — 线性代数 1 — 背景知识 1","uri":"/2020/05/gsl%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"},{"categories":["GSL"],"content":"GSL 线性代数基本运算 (BLAS) 模块","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/","tags":["GSL","线性代数"],"title":"GSL 系列 5 — 向量和矩阵 4 — 基本线性代数运算 (BLAS)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/"},{"categories":["GSL"],"content":"1 写在前面 关于向量，矩阵的定义参考 向量 (vector) 矩阵 (matrix) 若无特别说明，本篇代码均来自头文件 gsl_blas.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/:1:0","tags":["GSL","线性代数"],"title":"GSL 系列 5 — 向量和矩阵 4 — 基本线性代数运算 (BLAS)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/"},{"categories":["GSL"],"content":"2 概述 将基本的线代运算分为三个层次： 层次1，向量运算，比如 $\\alpha x+y$ 层次2，矩阵和向量的运算，比如 $\\alpha Ax+\\beta y$ 层次3，矩阵和矩阵的运算，比如 $\\alpha AB+C$ 将如下矩阵类型做名字简单的名字标记： 名字标记 矩阵类型 名字标记 矩阵类型 GE 一般矩阵 GB 一般带矩阵 SY 对称矩阵 SB 对称带矩阵 SP 对称矩阵包 HE 共轭矩阵 HB 共轭带矩阵 HP 共轭矩阵包 TR 三角矩阵 TB 三角带矩阵 TP 三角矩阵包 以下名字标记代表线代运算 名字标记 矩阵运算 DOT 标量乘 $x^Ty$ AXPY 向量加 $\\alpha x+y$ MV 矩阵向量乘 $Ax$ SV 矩阵向量求解 $A^{-1}b$ MM 矩阵矩阵乘 $AA$ SM 矩阵矩阵求解 $A^{-1}B$ 以下名字标记代表数据类型 名字标记 数据类型 S 单精度实数 D 双精度实数 C 单精度复数 Z 双精度复数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/:2:0","tags":["GSL","线性代数"],"title":"GSL 系列 5 — 向量和矩阵 4 — 基本线性代数运算 (BLAS)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/"},{"categories":["GSL"],"content":"3 层次 1 运算 $\\alpha +x^Ty$ int gsl_blas_sdsdot (float alpha, const gsl_vector_float * X, const gsl_vector_float * Y, float * result ); $x^Ty$ int gsl_blas_dsdot (const gsl_vector_float * X, const gsl_vector_float * Y, double * result ); int gsl_blas_sdot (const gsl_vector_float * X, const gsl_vector_float * Y, float * result ); int gsl_blas_ddot (const gsl_vector * X, const gsl_vector * Y, double * result ); int gsl_blas_cdotu (const gsl_vector_complex_float * X, const gsl_vector_complex_float * Y, gsl_complex_float * dotu); int gsl_blas_zdotu (const gsl_vector_complex * X, const gsl_vector_complex * Y, gsl_complex * dotu); $x^Hy$ int gsl_blas_cdotc (const gsl_vector_complex_float * X, const gsl_vector_complex_float * Y, gsl_complex_float * dotc); int gsl_blas_zdotc (const gsl_vector_complex * X, const gsl_vector_complex * Y, gsl_complex * dotc); $|x|_2$ float gsl_blas_snrm2 (const gsl_vector_float * X); double gsl_blas_dnrm2 (const gsl_vector * X); float gsl_blas_scnrm2 (const gsl_vector_complex_float * X); double gsl_blas_dznrm2 (const gsl_vector_complex * X); $\\sum|x_i|$ float gsl_blas_sasum (const gsl_vector_float * X); double gsl_blas_dasum (const gsl_vector * X); $\\sum\\left(\\left|\\Re\\left(x_{i}\\right)\\right|+\\left|\\Im\\left(x_{i}\\right)\\right|\\right)$ float gsl_blas_scasum (const gsl_vector_complex_float * X); double gsl_blas_dzasum (const gsl_vector_complex * X); $\\max_i|x_i|$ CBLAS_INDEX_t gsl_blas_isamax (const gsl_vector_float * X); CBLAS_INDEX_t gsl_blas_idamax (const gsl_vector * X); // gsl_blas_types.h typedef CBLAS_INDEX CBLAS_INDEX_t; // gsl_cblas.h #define CBLAS_INDEX size_t $\\max_i(\\left|\\Re\\left(x_{i}\\right)\\right|+\\left|\\Im\\left(x_{i}\\right)\\right|)$ CBLAS_INDEX_t gsl_blas_icamax (const gsl_vector_complex_float * X); CBLAS_INDEX_t gsl_blas_izamax (const gsl_vector_complex * X); 交换 $x$，$y$ int gsl_blas_sswap (gsl_vector_float * X, gsl_vector_float * Y); int gsl_blas_dswap (gsl_vector * X, gsl_vector * Y); int gsl_blas_cswap (gsl_vector_complex_float * X, gsl_vector_complex_float * Y); int gsl_blas_zswap (gsl_vector_complex * X, gsl_vector_complex * Y); 复制 $x$ 到 $y$ int gsl_blas_scopy (const gsl_vector_float * X, gsl_vector_float * Y); int gsl_blas_dcopy (const gsl_vector * X, gsl_vector * Y); int gsl_blas_ccopy (const gsl_vector_complex_float * X, gsl_vector_complex_float * Y); int gsl_blas_zcopy (const gsl_vector_complex * X, gsl_vector_complex * Y); $y=\\alpha x+y$ int gsl_blas_saxpy (float alpha, const gsl_vector_float * X, gsl_vector_float * Y); int gsl_blas_daxpy (double alpha, const gsl_vector * X, gsl_vector * Y); int gsl_blas_caxpy (const gsl_complex_float alpha, const gsl_vector_complex_float * X, gsl_vector_complex_float * Y); int gsl_blas_zaxpy (const gsl_complex alpha, const gsl_vector_complex * X, gsl_vector_complex * Y); $\\alpha x$ void gsl_blas_sscal (float alpha, gsl_vector_float * X); void gsl_blas_dscal (double alpha, gsl_vector * X); void gsl_blas_cscal (const gsl_complex_float alpha, gsl_vector_complex_float * X); void gsl_blas_zscal (const gsl_complex alpha, gsl_vector_complex * X); void gsl_blas_csscal (float alpha, gsl_vector_complex_float * X); void gsl_blas_zdscal (double alpha, gsl_vector_complex * X); 计算满足如下旋转: $$\\left(\\begin{array}{cc}c \u0026 s \\ -s \u0026 c\\end{array}\\right)\\left(\\begin{array}{l}a \\ b\\end{array}\\right)=\\left(\\begin{array}{l}r^{\\prime} \\ 0\\end{array}\\right)$$ 计算得到 c, s，同时，a, b 也进行重写 int gsl_blas_srotg (float a[], float b[], float c[], float s[]); int gsl_blas_drotg (double a[], double b[], double c[], double s[]); 应用旋转，计算 $(x,y) = (cx+sy,-sx+cy)$ int gsl_blas_srot (gsl_vector_float * X, gsl_vector_float * Y, float c, float s); int gsl_blas_drot (gsl_vector * X, gsl_vector * Y, const double c, const double s); 计算修正旋转 int gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[]); int gsl_blas_drotmg (double d1[], double d2[], double b1[], double b2, double P[]); 应用修正旋转 int gsl_blas_srotm (gsl_vector_float * X, gsl_vector_float * Y, const float P[]); int gsl_blas_d","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/:3:0","tags":["GSL","线性代数"],"title":"GSL 系列 5 — 向量和矩阵 4 — 基本线性代数运算 (BLAS)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/"},{"categories":["GSL"],"content":"4 层次 2 运算 $y=\\alpha \\operatorname{op}(A)x+\\beta y$ 当 TransA 等于 CblasNoTrans，CblasTrans，CblasConjTrans 时，$\\operatorname{op}(A)$ 分别等于 $A$，$A^T$，$A^H$ int gsl_blas_sgemv (CBLAS_TRANSPOSE_t TransA, float alpha, const gsl_matrix_float * A, const gsl_vector_float * X, float beta, gsl_vector_float * Y); int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransA, double alpha, const gsl_matrix * A, const gsl_vector * X, double beta, gsl_vector * Y); int gsl_blas_cgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_vector_complex_float * X, const gsl_complex_float beta, gsl_vector_complex_float * Y); int gsl_blas_zgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_vector_complex * X, const gsl_complex beta, gsl_vector_complex * Y); // gsl_blas_types.h typedef enum CBLAS_TRANSPOSE CBLAS_TRANSPOSE_t; // gsl_cblas.h enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113}; 三角矩阵，$\\operatorname{op}(A)x$ 当 Uplo 为 CblasUpper，CblasLower 时，分别使用 A 的上三角，下三角部分 当 Diag 为 CblasNonUnit，CblasUnit 时，分别使用 A 的对角线，为 1 的对角线 int gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_float * A, gsl_vector_float * X); int gsl_blas_dtrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X); int gsl_blas_ctrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A, gsl_vector_complex_float * X); int gsl_blas_ztrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex * A, gsl_vector_complex * X); // gsl_blas_types.h typedef enum CBLAS_UPLO CBLAS_UPLO_t; typedef enum CBLAS_DIAG CBLAS_DIAG_t; // gsl_cblas.h enum CBLAS_UPLO {CblasUpper=121, CblasLower=122}; enum CBLAS_DIAG {CblasNonUnit=131, CblasUnit=132}; 三角矩阵，$inv(\\operatorname{op}(A))x$ int gsl_blas_strsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_float * A, gsl_vector_float * X); int gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X); int gsl_blas_ctrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A, gsl_vector_complex_float * X); int gsl_blas_ztrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex * A, gsl_vector_complex *X); 对称矩阵，$y=\\alpha Ax+\\beta y$ int gsl_blas_ssymv (CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A, const gsl_vector_float * X, float beta, gsl_vector_float * Y); int gsl_blas_dsymv (CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A, const gsl_vector * X, double beta, gsl_vector * Y); 共轭矩阵，$y=\\alpha Ax+\\beta y$ int gsl_blas_chemv (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_vector_complex_float * X, const gsl_complex_float beta, gsl_vector_complex_float * Y); int gsl_blas_zhemv (CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_vector_complex * X, const gsl_complex beta, gsl_vector_complex * Y); $A=\\alpha xy^T+A$ int gsl_blas_sger (float alpha, const gsl_vector_float * X, const gsl_vector_float * Y, gsl_matrix_float * A); int gsl_blas_dger (double alpha, const gsl_vector * X, const gsl_vector * Y, gsl_matrix * A); int gsl_blas_cgeru (const gsl_complex_float alpha, const gsl_vector_complex_float * X, const gsl_vector_complex_float * Y, gsl_matrix_complex_float * A); int gsl_blas_zgeru (const gsl_complex alpha, const gsl_vector_complex * X, const gsl_vector_complex * Y, gsl_matrix_complex * A); $A=\\alpha xy^H+A$ int gsl_blas_cgerc (const gsl_complex_float alpha, const gsl_vector_complex_float * X, const gsl_vector_complex_float * Y, gsl_matrix_complex_float * A); int gsl_blas_zgerc (const gsl_complex alpha, const gsl_vector_complex * X, const gsl_vector_complex * Y, gsl_matrix_complex * A); 对称矩阵，$A=\\alpha xx^T+A$ int gsl_bl","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/:4:0","tags":["GSL","线性代数"],"title":"GSL 系列 5 — 向量和矩阵 4 — 基本线性代数运算 (BLAS)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/"},{"categories":["GSL"],"content":"5 层次 3 运算 $C=\\alpha\\operatorname{op}(A)\\operatorname{op}(B)+\\beta C$ int gsl_blas_sgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, float alpha, const gsl_matrix_float * A, const gsl_matrix_float * B, float beta, gsl_matrix_float * C); int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, double alpha, const gsl_matrix * A, const gsl_matrix * B, double beta, gsl_matrix * C); int gsl_blas_cgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C); int gsl_blas_zgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C); 对称矩阵 $A$；$C=\\alpha AB+\\beta C$ 或 $C=\\alpha BA+\\beta C$ 当 Side 为 CblasLeft，CblasRight 时，分别计算 $C=\\alpha AB+\\beta C$，$C=\\alpha BA+\\beta C$ int gsl_blas_ssymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A, const gsl_matrix_float * B, float beta, gsl_matrix_float * C); int gsl_blas_dsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A, const gsl_matrix * B, double beta, gsl_matrix * C); int gsl_blas_csymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C); int gsl_blas_zsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C); // gsl_blas_types.h typedef enum CBLAS_SIDE CBLAS_SIDE_t; // gsl_cblas.h enum CBLAS_SIDE {CblasLeft=141, CblasRight=142}; 共轭矩阵 $A$；$C=\\alpha AB+\\beta C$ 或 $C=\\alpha BA+\\beta C$ int gsl_blas_chemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C); int gsl_blas_zhemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C); 三角矩阵 $A$；$B=\\alpha\\operatorname{op}(A)B$ 或 $B=\\alpha B\\operatorname{op}(A)$ int gsl_blas_strmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha, const gsl_matrix_float * A, gsl_matrix_float * B); int gsl_blas_dtrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha, const gsl_matrix * A, gsl_matrix * B); int gsl_blas_ctrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, gsl_matrix_complex_float * B); int gsl_blas_ztrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex alpha, const gsl_matrix_complex * A, gsl_matrix_complex * B); 三角矩阵 $A$；$B=\\alpha\\operatorname{op}(inv(A))B$ 或 $B=\\alpha B\\operatorname{op}(inv(A))$ int gsl_blas_strsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha, const gsl_matrix_float * A, gsl_matrix_float * B); int gsl_blas_dtrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha, const gsl_matrix * A, gsl_matrix * B); int gsl_blas_ctrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, gsl_matrix_complex_float * B); int gsl_blas_ztrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex alpha, const gsl_matrix_complex * A, gsl_matrix_complex * B); 对称矩阵 $C$；$C=\\alpha AA^T+\\beta C$ int gsl_blas_ssyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha, const gsl_matrix_f","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/:5:0","tags":["GSL","线性代数"],"title":"GSL 系列 5 — 向量和矩阵 4 — 基本线性代数运算 (BLAS)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B54/"},{"categories":["GSL"],"content":"GSL 矩阵结构","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"1 写在前面 因为矩阵是构建于块之上，请先理解块，参见：块 (block) 如果没有特殊说明，本篇代码均来自头文件 gsl_matrix_double.h，即以下的类型，函数等都是基于double 的。对于其他数据类型的类型、函数等，都是与之类似。 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:1:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"2 矩阵 矩阵建构在 block 之上，是对 block 的切片描述。矩阵结构定义如下： typedef struct { size_t size1; // 矩阵维度 1 —— 多少行 size_t size2; // 矩阵纬度 2 —— 多少列 size_t tda; // 物理行尺寸 double * data; // 指向矩阵 gsl_block * block; // 指向矩阵对应 block int owner; // 矩阵对 block 的所有权 } gsl_matrix; 所有权的解释参见：所有权 矩阵是按行存储的，即在内存中，一行是连续的。 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:2:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"3 矩阵内存分配和释放 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:3:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"3.1 矩阵分配和释放 // n1 行，n2 列 gsl_matrix_alloc(const size_t n1, const size_t n2); // 无初始化 gsl_matrix * gsl_matrix_calloc(const size_t n1, const size_t n2); // 初始化为 0 // 根据块分配 gsl_matrix * gsl_matrix_alloc_from_block(gsl_block * b, const size_t offset, const size_t n1, const size_t n2, const size_t d2); // 根据矩阵分配, k1 k2 是分配的矩阵左上角在原矩阵的索引 gsl_matrix * gsl_matrix_alloc_from_matrix(gsl_matrix * m, const size_t k1, const size_t k2, const size_t n1, const size_t n2); // 释放 void gsl_matrix_free(gsl_matrix * m); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:3:1","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"3.2 从矩阵中分配向量内存 // 根据矩阵分配向量内存 gsl_vector * gsl_vector_alloc_row_from_matrix(gsl_matrix * m, const size_t i); gsl_vector * gsl_vector_alloc_col_from_matrix(gsl_matrix * m, const size_t j); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:3:2","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"4 矩阵元素获取 // HAVE_INLINE 定义时，使用内联 INLINE_DECL double gsl_matrix_get(const gsl_matrix * m, const size_t i, const size_t j); INLINE_DECL void gsl_matrix_set(gsl_matrix * m, const size_t i, const size_t j, const double x); INLINE_DECL double * gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j); INLINE_DECL const double * gsl_matrix_const_ptr(const gsl_matrix * m, const size_t i, const size_t j); 矩阵元素获取实际上是 mp-\u003edata[i * mp-\u003etda + j]，tda 即物理行尺寸 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:4:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"5 矩阵初始化 void gsl_matrix_set_zero(gsl_matrix * m); // 置 0 void gsl_matrix_set_identity(gsl_matrix * m); // 对角置 1，非对角置 0 void gsl_matrix_set_all(gsl_matrix * m, double x); // 置 x ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:5:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"6 矩阵读取和写入 和向量类似，参见：向量读取和写入 int gsl_matrix_fread(FILE * stream, gsl_matrix * m) ; int gsl_matrix_fwrite(FILE * stream, const gsl_matrix * m) ; int gsl_matrix_fscanf(FILE * stream, gsl_matrix * m); int gsl_matrix_fprintf(FILE * stream, const gsl_matrix * m, const char * format); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:6:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"7 矩阵及其行、列查看 (view) ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:7:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"7.1 矩阵查看对象 存放在栈区，有 const 和 非const，定义如下： typedef struct { gsl_matrix matrix; } _gsl_matrix_view; typedef _gsl_matrix_view gsl_matrix_view; typedef struct { gsl_matrix matrix; } _gsl_matrix_const_view; typedef const _gsl_matrix_const_view gsl_matrix_const_view; ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:7:1","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"7.2 返回矩阵查看对象 // 从矩阵中返回矩阵查看对象 // i,j 是返回对象在原矩阵的左上角坐标 // n1, n2 是返回对象的行数，列数 _gsl_matrix_view gsl_matrix_submatrix(gsl_matrix * m, const size_t i, const size_t j, const size_t n1, const size_t n2); _gsl_matrix_const_view gsl_matrix_const_submatrix(const gsl_matrix * m, const size_t i, const size_t j, const size_t n1, const size_t n2); // 从数组中返回矩阵查看对象 // tda 是物理行尺寸 _gsl_matrix_view gsl_matrix_view_array(double * base, const size_t n1, const size_t n2); _gsl_matrix_view gsl_matrix_view_array_with_tda(double * base, const size_t n1, const size_t n2, const size_t tda); // 从向量中返回矩阵查看对象 _gsl_matrix_view gsl_matrix_view_vector(gsl_vector * v, const size_t n1, const size_t n2); _gsl_matrix_view gsl_matrix_view_vector_with_tda(gsl_vector * v, const size_t n1, const size_t n2, const size_t tda); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:7:2","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"7.3 根据矩阵返回向量查看对象 // 第 i 行 _gsl_vector_view gsl_matrix_row(gsl_matrix * m, const size_t i); _gsl_vector_const_view gsl_matrix_const_row(const gsl_matrix * m, const size_t i); // 第 i 行，偏置 offset, n 个元素 _gsl_vector_view gsl_matrix_subrow(gsl_matrix * m, const size_t i, const size_t offset, const size_t n); _gsl_vector_const_view gsl_matrix_const_subrow(const gsl_matrix * m, const size_t i, const size_t offset, const size_t n); // 第 i 列 _gsl_vector_view gsl_matrix_column(gsl_matrix * m, const size_t j); _gsl_vector_const_view gsl_matrix_const_column(const gsl_matrix * m, const size_t j); // 第 i 列，偏置 offset, n 个元素 _gsl_vector_view gsl_matrix_subcolumn(gsl_matrix * m, const size_t j, const size_t offset, const size_t n); _gsl_vector_const_view gsl_matrix_const_subcolumn(const gsl_matrix * m, const size_t j, const size_t offset, const size_t n); // 对角 _gsl_vector_view gsl_matrix_diagonal(gsl_matrix * m); _gsl_vector_const_view gsl_matrix_const_diagonal(const gsl_matrix * m); // 子对角 _gsl_vector_view gsl_matrix_subdiagonal(gsl_matrix * m, const size_t k); _gsl_vector_const_view gsl_matrix_const_subdiagonal(const gsl_matrix * m, const size_t k); // 超对角 _gsl_vector_view gsl_matrix_superdiagonal(gsl_matrix * m, const size_t k); _gsl_vector_const_view gsl_matrix_const_superdiagonal(const gsl_matrix * m, const size_t k); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:7:3","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"8 矩阵及其行、列复制 // 复制一个矩阵到另一个矩阵 int gsl_matrix_memcpy(gsl_matrix * dest, const gsl_matrix * src); // 复制矩阵的行、列到向量中 int gsl_matrix_get_row(gsl_vector * v, const gsl_matrix * m, const size_t i); int gsl_matrix_get_col(gsl_vector * v, const gsl_matrix * m, const size_t j); // 复制向量到矩阵的行、列中 int gsl_matrix_set_row(gsl_matrix * m, const size_t i, const gsl_vector * v); int gsl_matrix_set_col(gsl_matrix * m, const size_t j, const gsl_vector * v); 注意：源码中提到，上面的后四个函数是过时的。 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:8:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"9 矩阵及其行、列交换 // 交换两个矩阵 int gsl_matrix_swap(gsl_matrix * m1, gsl_matrix * m2); // 交换矩阵的行与列 int gsl_matrix_swap_rows(gsl_matrix * m, const size_t i, const size_t j); int gsl_matrix_swap_columns(gsl_matrix * m, const size_t i, const size_t j); int gsl_matrix_swap_rowcol(gsl_matrix * m, const size_t i, const size_t j); // 将矩阵 src 转置复制给目标矩阵 dest int gsl_matrix_transpose_memcpy(gsl_matrix * dest, const gsl_matrix * src); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:9:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"10 矩阵运算 int gsl_matrix_transpose(gsl_matrix * m); // 矩阵转置 // 以下计算结果保存到 a int gsl_matrix_add(gsl_matrix * a, const gsl_matrix * b); // a+b int gsl_matrix_sub(gsl_matrix * a, const gsl_matrix * b); // a-b int gsl_matrix_mul_elements(gsl_matrix * a, const gsl_matrix * b); // a*b int gsl_matrix_div_elements(gsl_matrix * a, const gsl_matrix * b); // a/b int gsl_matrix_scale(gsl_matrix * a, const double x); // xa int gsl_matrix_add_constant(gsl_matrix * a, const double x); // a+x, x 加到 a 每一个元素 int gsl_matrix_add_diagonal(gsl_matrix * a, const double x); // a+x, x 加到 a 的对角元素 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:10:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"11 找寻矩阵最大、最小元素 double gsl_matrix_max(const gsl_matrix * m); double gsl_matrix_min(const gsl_matrix * m); void gsl_matrix_minmax(const gsl_matrix * m, double * min_out, double * max_out); void gsl_matrix_max_index(const gsl_matrix * m, size_t * imax, size_t *jmax); void gsl_matrix_min_index(const gsl_matrix * m, size_t * imin, size_t *jmin); void gsl_matrix_minmax_index(const gsl_matrix * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:11:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"12 矩阵判断 // 两个矩阵是否相等 int gsl_matrix_equal (const gsl_matrix * a, const gsl_matrix * b); // 以下判断是对矩阵的所有元素 int gsl_matrix_isnull (const gsl_matrix * m); // 是否为 0 int gsl_matrix_ispos (const gsl_matrix * m); // 是否为 正 int gsl_matrix_isneg (const gsl_matrix * m); // 是否为 负 int gsl_matrix_isnonneg (const gsl_matrix * m); // 是否为 非负 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/:12:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 3 — 矩阵 (matrix)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B53/"},{"categories":["GSL"],"content":"GSL 向量结构","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"1 写在前面 因为向量是构建于块之上，请先理解块，参见：块 (block) 如果没有特殊说明，本篇代码均来自头文件 gsl_vector_double.h，即以下的类型，函数等都是基于double 的。对于其他数据类型的类型、函数等，都是与之类似。 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:1:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"2 向量 (vector) 向量建构于块之上，添加了对块的切片描述，向量切片必须是内存空间中一组等间隔的元素，不同的向量可以创建于一个块之上，定义如下： typedef struct { size_t size; // 向量元素个数 size_t stride; // 相邻元素的物理空间步长 double *data; // 向量的指针，地址为向量的第一个元素 gsl_block *block; // 向量的数据基础快的指针 int owner; // 向量对块的所有权 } gsl_vector; 上述注释中，向量对块的所有权是指，当向量对块有所有权 (owner=1) 时，向量内存在释放时，块内存也会得到释放 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:2:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"3 向量内存分配和释放 gsl_vector *gsl_vector_alloc(const size_t n); // 分配一个长度为 n 的向量，无初始化 gsl_vector *gsl_vector_calloc(const size_t n); // 分配一个长度为 n 的向量，初始化为 0 // 根据块分配向量内存 gsl_vector *gsl_vector_alloc_from_block(gsl_block * b, const size_t offset, const size_t n, const size_t stride); // 根据向量分配向量内存 gsl_vector *gsl_vector_alloc_from_vector(gsl_vector * v, const size_t offset, const size_t n, const size_t stride); void gsl_vector_free(gsl_vector * v); // 向量内存释放 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:3:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"4 获取向量元素 包含一个向量元素设定函数 // HAVE_INLINE 定义时下列函数使用 内联 // 获取向量第 i 个元素 INLINE_DECL double gsl_vector_get(const gsl_vector * v, const size_t i); // 设定向量第 i 个元素 INLINE_DECL void gsl_vector_set(gsl_vector * v, const size_t i, double x); // 返回第 i 个元素的指针 INLINE_DECL double * gsl_vector_ptr(gsl_vector * v, const size_t i); INLINE_DECL const double * gsl_vector_const_ptr(const gsl_vector * v, const size_t i); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:4:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"5 向量初始化 // 初始化为 0 void gsl_vector_set_zero(gsl_vector * v); // 初始化为 x void gsl_vector_set_all(gsl_vector * v, double x); // 第 i 个元素设为 1， 其他元素设为 0 int gsl_vector_set_basis(gsl_vector * v, size_t i); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:5:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"6 向量读取和写入 // 以下函数，成功返回 0，否则 错误 GSL_EFAILED // 以二进制 从 流 读到 向量 中，向量需分配好合适的长度 int gsl_vector_fread(FILE * stream, gsl_vector * v); // 以二进制 从 向量 写到 流 中 int gsl_vector_fwrite(FILE * stream, const gsl_vector * v); // 以格式化的数据 从 流 读到 向量 中，向量需分配好合适的长度 int gsl_vector_fscanf(FILE * stream, gsl_vector * v); // 以格式化的方式 从 向量 写到 流 中 // %g, %e, %f 用于浮点数 %d 用于整数 int gsl_vector_fprintf(FILE * stream, const gsl_vector * v, const char *format); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:6:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"7 向量查看 (view) ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:7:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"7.1 向量查看对象 向量查看对象是放在栈区的，有非 const 和 const 两种，定义如下 typedef struct { gsl_vector vector; } _gsl_vector_view; typedef _gsl_vector_view gsl_vector_view; typedef struct { gsl_vector vector; } _gsl_vector_const_view; typedef const _gsl_vector_const_view gsl_vector_const_view; ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:7:1","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"7.2 返回向量查看对象 除了根据以下方式返回向量查看对象，还可以根据矩阵返回向量查看对象，具体参见：根据矩阵返回向量查看对象 // 根据数组，返回向量查看对象，长度为 n _gsl_vector_view gsl_vector_view_array(double *v, size_t n); _gsl_vector_view gsl_vector_view_array_with_stride(double *base, size_t stride, size_t n); _gsl_vector_const_view gsl_vector_const_view_array(const double *v, size_t n); _gsl_vector_const_view gsl_vector_const_view_array_with_stride(const double *base, size_t stride, size_t n); // 根据 向量 返回一个向量查看对象, i 是原向量的偏置，n 是 新向量查看对象对应的长度 _gsl_vector_view gsl_vector_subvector(gsl_vector *v, size_t i, size_t n); _gsl_vector_view gsl_vector_subvector_with_stride(gsl_vector *v, size_t i, size_t stride, size_t n); _gsl_vector_const_view gsl_vector_const_subvector(const gsl_vector *v, size_t i, size_t n); _gsl_vector_const_view gsl_vector_const_subvector_with_stride(const gsl_vector *v, size_t i, size_t stride, size_t n); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:7:2","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"8 向量复制和交换 // 将向量 src 复制到 向量 dest 中 int gsl_vector_memcpy(gsl_vector * dest, const gsl_vector * src); // 将向量 v 反序 int gsl_vector_reverse(gsl_vector * v); // 交换向量 v 和 w int gsl_vector_swap(gsl_vector * v, gsl_vector * w); // 交换向量 v 的第 i 和 j 个元素 int gsl_vector_swap_elements(gsl_vector * v, const size_t i, const size_t j); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:8:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"9 向量运算 // 以下运算结果保存在 a 中 int gsl_vector_add(gsl_vector * a, const gsl_vector * b); // a+b int gsl_vector_sub(gsl_vector * a, const gsl_vector * b); // a-b int gsl_vector_mul(gsl_vector * a, const gsl_vector * b); // a*b, 元素乘 int gsl_vector_div(gsl_vector * a, const gsl_vector * b); // a/b，元素除 int gsl_vector_scale(gsl_vector * a, const double x); // xa int gsl_vector_add_constant(gsl_vector * a, const double x); // a+[x,..,x] // 以下运算将结果保存在 y 中 int gsl_vector_axpby(const double alpha, const gsl_vector * x, const double beta, gsl_vector * y); // alpha x + beta y ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:9:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"10 找寻向量的最大最小元素 double gsl_vector_max (const gsl_vector * v); // 返回最大值 double gsl_vector_min (const gsl_vector * v); // 返回最小值 // 返回最大值，最小值，存在 max_out, min_out 中 void gsl_vector_minmax (const gsl_vector * v, double * min_out, double * max_out); size_t gsl_vector_max_index (const gsl_vector * v); // 返回最大值索引 size_t gsl_vector_min_index (const gsl_vector * v); // 返回最小值索引 // 返回最大，最小值索引，存放在 imax, imin 中 void gsl_vector_minmax_index (const gsl_vector * v, size_t * imin, size_t * imax); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:10:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"11 向量判断 // 满足条件返回 1 ，否则 0 int gsl_vector_equal(const gsl_vector * u, const gsl_vector * v); // 两向量是否相等 int gsl_vector_isnull(const gsl_vector * v); // 向量所有元素为 0 int gsl_vector_ispos(const gsl_vector * v); // 向量所有元素为 正 int gsl_vector_isneg(const gsl_vector * v); // 向量所有元素为 负 int gsl_vector_isnonneg(const gsl_vector * v); // 向量所有元素为 非负 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/:11:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 2 — 向量 (vector)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B52/"},{"categories":["GSL"],"content":"GSL 向量和矩阵数据结构的基础 block","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 1 — 块 (block)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/"},{"categories":["GSL"],"content":"1 块 (block) 块是向量，矩阵数据存储的基本结构，包含两个部分： 块内存的size 块内存的指针 默认的 gsl_block 块是 double 类型数据，定义如下： // gsl_block_double.h struct gsl_block_struct { size_t size; double *data; }; typedef struct gsl_block_struct gsl_block; // vcruntime.h typedef unsigned __int64 size_t; 如果需要用其他数据类型的块，则在后边加上对应的类型名称，比如 gsl_block_float ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/:1:0","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 1 — 块 (block)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/"},{"categories":["GSL"],"content":"1.1 块内存的分配和释放 // gsl_block_double.h gsl_block *gsl_block_alloc(const size_t n); // 分配不初始化，返回指针 gsl_block *gsl_block_calloc(const size_t n); // 分配并初始化为 0，返回指针 void gsl_block_free(gsl_block * b); // 通过指针，内存释放 在没有足够的内存分配时，块内存分配函数会调用错误句柄返回 GSL_ENOMEM 错误，以及空指针 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/:1:1","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 1 — 块 (block)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/"},{"categories":["GSL"],"content":"1.2 块内存读写 // gsl_block_double.h /* 以 二进制 将 块 写入 流 中，成功返回 0， 失败则 GSL_EFAILED */ int gsl_block_fread(FILE * stream, gsl_block * b); /* 以 二进制 从 流 读到 块 中，成功返回 0， 失败则 GSL_EFAILED 块 b 需要预先分配好正确的长度，因为是以 b 的内存大小读入的 */ int gsl_block_fwrite(FILE * stream, const gsl_block * b); /* 以 格式化的数据 从 流 读到 块 中，成功返回 0， 失败则 GSL_EFAILED 块 b 需要预先分配好正确的长度，因为是以 b 的内存大小读入的 */ int gsl_block_fscanf(FILE * stream, gsl_block * b); /* 以 格式化的方式 从 块 写入 流 中，成功返回 0， 失败则 GSL_EFAILED %g, %e, %f 用于浮点数，%d 用于整数 */ int gsl_block_fprintf(FILE * stream, const gsl_block * b, const char *format); int gsl_block_raw_fread(FILE * stream, double * b, const size_t n, const size_t stride); int gsl_block_raw_fwrite(FILE * stream, const double * b, const size_t n, const size_t stride); int gsl_block_raw_fscanf(FILE * stream, double * b, const size_t n, const size_t stride); int gsl_block_raw_fprintf(FILE * stream, const double * b, const size_t n, const size_t stride, const char *format); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/:1:2","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 1 — 块 (block)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/"},{"categories":["GSL"],"content":"1.3 通过函数获取块的成员 // gsl_block_double.h size_t gsl_block_size (const gsl_block * b); double * gsl_block_data (const gsl_block * b); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/:1:3","tags":["GSL"],"title":"GSL 系列 5 — 向量和矩阵 1 — 块 (block)","uri":"/2020/05/gsl%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B51/"},{"categories":["GSL"],"content":"GSL 特殊函数 4","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"1 写在前面 对以下变量参见：变量定义 gsl_sf_result * result gsl_mode_t mode gsl_sf_result_e10 * result ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:1:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"2 本篇包含的特殊函数 克劳森 (Clausen) 函数 道森 (Dawson) 函数 德拜 (Debye) 函数 双重对数 (Dilogarithm) 误差 (Error) 函数 费米—狄拉克 (Fermi-Dirac) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:2:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"3 克劳森 (Clausen) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:3:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"基本公式 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:3:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"计算 头文件：gsl_sf_clausen.h int gsl_sf_clausen_e(double x, gsl_sf_result * result); double gsl_sf_clausen(const double x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:3:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"4 道森 (Dawson) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:4:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"基本公式 $$D_{+}(x)=e^{-x^{2}} \\int_{0}^{x} e^{t^{2}} d t$$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:4:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"计算 头文件：gsl_sf_dawson.h int gsl_sf_dawson_e(double x, gsl_sf_result * result); double gsl_sf_dawson(double x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:4:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"5 德拜 (Debye) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:5:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"基本公式 $$D_{n}(x)=\\frac{n}{x^{n}} \\int_{0}^{x} \\frac{t^{n}}{e^{t}-1} d t$$ $n$ 为阶数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:5:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"计算 头文件：gsl_sf_debye.h // 一阶 int gsl_sf_debye_1_e(const double x, gsl_sf_result * result); double gsl_sf_debye_1(const double x); // 2 阶 int gsl_sf_debye_2_e(const double x, gsl_sf_result * result); double gsl_sf_debye_2(const double x); // 3 阶 int gsl_sf_debye_3_e(const double x, gsl_sf_result * result); double gsl_sf_debye_3(const double x); // 4 阶 int gsl_sf_debye_4_e(const double x, gsl_sf_result * result); double gsl_sf_debye_4(const double x); // 5 阶 int gsl_sf_debye_5_e(const double x, gsl_sf_result * result); double gsl_sf_debye_5(const double x); // 6 阶 int gsl_sf_debye_6_e(const double x, gsl_sf_result * result); double gsl_sf_debye_6(const double x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:5:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"6 双重对数 (Dilogarithm) ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:6:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"基本公式 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:6:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"计算 头文件：gsl_sf_dilog.h // 实变量计算 int gsl_sf_dilog_e(const double x, gsl_sf_result * result); double gsl_sf_dilog(const double x); //复变量计算 // 输入 x, y, 笛卡尔坐标 int gsl_sf_complex_dilog_xy_e( const double x, const double y, gsl_sf_result * result_re, gsl_sf_result * result_im ); // 输入 r, theta, 极坐标 // 头文件中提到此函数不推荐使用 int gsl_sf_complex_dilog_e( const double r, const double theta, gsl_sf_result * result_re, gsl_sf_result * result_im ); // 计算 Li_2(1-z) int gsl_sf_complex_spence_xy_e( const double x, const double y, gsl_sf_result * real_sp, gsl_sf_result * imag_sp ); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:6:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"7 误差 (Error) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:7:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"基本公式 误差函数 $$\\operatorname{erf}( x)=\\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-t^{2}} d t$$ 误差补函数 $$\\operatorname{erfc}( x) = 1-\\operatorname{erf}( x)$$ 对数误差补函数 $$\\operatorname{ln}(\\operatorname{erfc}( x))$$ 标准正态分布概率密度函数 $$Z(x)=\\frac{1}{\\sqrt{2 \\pi}} e^{-\\frac{1}{2} x^{2}}$$ Q 函数 $$Q(x)=\\frac{1}{\\sqrt{2 \\pi}} \\int_{x}^{\\infty} \\exp \\left(-\\frac{u^{2}}{2}\\right) d u=\\frac{1}{2}\\operatorname{erfc}(\\frac{x}{\\sqrt{2}})$$ 危险函数 $$H(x)=\\frac{Z(x)}{Q(x)}=\\sqrt{\\frac{2}{\\pi}}\\frac{e^{-\\frac{1}{2} x^{2}}}{\\operatorname{erfc}(\\frac{x}{\\sqrt{2}})}$$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:7:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"计算 头文件：gsl_sf_erf.h // erfc int gsl_sf_erfc_e(double x, gsl_sf_result * result); double gsl_sf_erfc(double x); // ln erfc int gsl_sf_log_erfc_e(double x, gsl_sf_result * result); double gsl_sf_log_erfc(double x); // erf int gsl_sf_erf_e(double x, gsl_sf_result * result); double gsl_sf_erf(double x); // Z, Q int gsl_sf_erf_Z_e(double x, gsl_sf_result * result); int gsl_sf_erf_Q_e(double x, gsl_sf_result * result); double gsl_sf_erf_Z(double x); double gsl_sf_erf_Q(double x); // H int gsl_sf_hazard_e(double x, gsl_sf_result * result); double gsl_sf_hazard(double x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:7:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"8 费米—狄拉克 (Fermi-Dirac) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:8:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"基本公式 完全费米—狄拉克积分 $$F_{j}(x)=\\frac{1}{\\Gamma(j+1)} \\int_{0}^{\\infty} \\frac{t^{j}}{e^{t-x}+1} d t$$ 非完全费米—狄拉克积分 $$F_{j}(x, b)=\\frac{1}{\\Gamma(j+1)} \\int_{b}^{\\infty} \\frac{t^{j}}{\\exp (t-x)+1} d t$$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:8:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"计算 头文件：gsl_sf_fermi_dirac.h // 完全 // j = -1 F_{-1}(x) = e^x / (1 + e^x) int gsl_sf_fermi_dirac_m1_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_m1(const double x); // j = 0 F_0(x) = ln(1 + e^x) int gsl_sf_fermi_dirac_0_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_0(const double x); // j = 1 int gsl_sf_fermi_dirac_1_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_1(const double x); // j = 2 int gsl_sf_fermi_dirac_2_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_2(const double x); // 整数 j int gsl_sf_fermi_dirac_int_e(const int j, const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_int(const int j, const double x); // j = -1/2 int gsl_sf_fermi_dirac_mhalf_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_mhalf(const double x); // j = 1/2 int gsl_sf_fermi_dirac_half_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_half(const double x); // j = 3/2 int gsl_sf_fermi_dirac_3half_e(const double x, gsl_sf_result * result); double gsl_sf_fermi_dirac_3half(const double x); // 非完全 // j = 0 int gsl_sf_fermi_dirac_inc_0_e(const double x, const double b, gsl_sf_result * result); double gsl_sf_fermi_dirac_inc_0(const double x, const double b); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/:8:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 4 — 其他特殊函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B04/"},{"categories":["GSL"],"content":"GSL 特殊函数 3","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"1 写在前面 对以下变量参见：变量定义 gsl_sf_result * result gsl_mode_t mode gsl_sf_result_e10 * result ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:1:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"2 头文件 若无特别说明，本篇代码均来自头文件 gsl_sf_bessel.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:2:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"3 贝塞尔 (Bessel) 函数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"基本介绍1 符号说明 $w^{\\prime \\prime} = \\frac{d^{2} w}{d z^{2}},w^{\\prime}=\\frac{d w}{d z}$ $z$ 为复数自变量 $\\nu$ 为复数常量 $n$ 为整数 3.1.2 贝塞尔函数 微分方程： $$z^{2} \\frac{d^{2} w}{d z^{2}}+z \\frac{d w}{d z}+\\left(z^{2}-\\nu^{2}\\right) {w}=0$$ 通解构成： 第一类贝塞尔函数：$J_{\\pm \\nu}(z)$ 第二类贝塞尔函数（韦伯函数）：$Y_{\\nu}(z)$ 第三类贝塞尔函数（汉克尔函数）：$H_{\\nu}^{(1)}(z)、H_{\\nu}^{(2)}(z)$ 关系式： $$J_{\\nu}(z)=\\left(\\frac{1}{2} z\\right)^{\\nu} \\sum_{k=0}^{\\infty} \\frac{\\left(-\\frac{1}{4} z^{2}\\right)^{k}}{k ! \\Gamma(\\nu+k+1)}$$ $$Y_{\\nu}(z)=\\frac{J_{{\\nu}}(z) \\cos ({\\nu} \\pi)-{J}_{-{\\nu}}({z})}{\\sin ({\\nu} \\pi)}$$ 阶数：$\\nu$ 修正贝塞尔函数 微分方程： $$z^{2} \\frac{d^{2} w}{d z^{2}}+z \\frac{d w}{d z}-\\left(z^{2}+\\nu^{2}\\right) w=0$$ 通解构成： 第一类修正贝塞尔函数：$I_{\\pm \\nu}(z)$ 第二类修正贝塞尔函数：$K_{\\nu}(z)$ 关系式： $$I_{\\nu}(z)=i^{-\\nu} J_{\\nu}(i z)$$ $$K_{\\nu}(z)=\\frac{1}{2} \\pi \\frac{I_{-\\nu}(z)-I_{\\nu}(z)}{\\sin (\\nu \\pi)}$$ 球贝塞尔函数 微分方程： $$z^{2} w^{\\prime \\prime}+2 z w^{\\prime}+\\left[z^{2}-n(n+1)\\right] w=0$$ 通解构成： 第一类球贝塞尔函数：$j_n(z)$ 第二类球贝塞尔函数：$y_n(z)$ 第三类球贝塞尔函数：$h_n^{(1)}(z),h_n^{(2)}(z)$ 关系式： $$j_{n}(z)=\\sqrt{\\frac{1}{2} \\pi / z} J_{n+\\frac{1}{2}}(z)$$ $$y_{n}(z)=\\sqrt{\\frac{1}{2} \\pi / z} Y_{n+\\frac{1}{2}}(z)$$ $$h_n^{(1)}(z) = j_n(z)+iy_n(z)$$ $$h_n^{(2)}(z) = j_n(z)-iy_n(z)$$ 修正球贝塞尔函数 微分方程： $$z^{2} w^{\\prime \\prime}+2 z w^{\\prime}-\\left[z^{2}+n(n+1)\\right] w=0$$ 通解构成： 第一类修正球贝塞尔函数：$\\sqrt{\\frac{1}{2} \\pi / z} I_{n+\\frac{1}{2}}(z)$ 第二类修正球贝塞尔函数：$\\sqrt{\\frac{1}{2} \\pi / z} I_{-n-\\frac{1}{2}}(z)$ 第三类修正球贝塞尔函数：$\\sqrt{\\frac{1}{2} \\pi / z} K_{n+\\frac{1}{2}}(z)$ 关系式： $$\\sqrt{\\frac{1}{2} \\pi / z} I_{n+\\frac{1}{2}}(z) = i^{-n}j_n(iz)$$ $$\\sqrt{\\frac{1}{2} \\pi / z} I_{-n-\\frac{1}{2}}(z)=i^{-(n+1)}y_n(iz)$$ $$\\sqrt{\\frac{1}{2} \\pi / z} K_{n+\\frac{1}{2}}(z)=\\frac{1}{2} \\pi(-1)^{n+1} \\sqrt{\\frac{1}{2} \\pi / z}\\left[I_{n+\\frac{1}{2}}(z)-I_{-n-\\frac{1}{2}}(z)\\right]$$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"贝塞尔函数计算 // 第一类 0 阶 int gsl_sf_bessel_J0_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_J0(const double x); // 第一类 1 阶 int gsl_sf_bessel_J1_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_J1(const double x); // 第一类 n 阶 int gsl_sf_bessel_Jn_e(int n, double x, gsl_sf_result * result); double gsl_sf_bessel_Jn(const int n, const double x); // 第一类 计算 nmin 到 nmax 阶，结果存在 result_array 中 int gsl_sf_bessel_Jn_array(int nmin, int nmax, double x, double * result_array); // 第一类 分数阶 nu int gsl_sf_bessel_Jnu_e(const double nu, const double x, gsl_sf_result * result); double gsl_sf_bessel_Jnu(const double nu, const double x); // 第一类 分数阶 nu , 计算贝塞尔函数在一系列 x 的值（数组 v，有序和正的） // 计算出来的结果放在数组 v, 数组 v 得到重写 int gsl_sf_bessel_sequence_Jnu_e(double nu, gsl_mode_t mode, size_t size, double * v); // 第二类，和第一类类似 int gsl_sf_bessel_Y0_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_Y0(const double x); int gsl_sf_bessel_Y1_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_Y1(const double x); int gsl_sf_bessel_Yn_e(int n,const double x, gsl_sf_result * result); double gsl_sf_bessel_Yn(const int n,const double x); int gsl_sf_bessel_Yn_array(const int nmin, const int nmax, const double x, double * result_array); int gsl_sf_bessel_Ynu_e(double nu, double x, gsl_sf_result * result); double gsl_sf_bessel_Ynu(const double nu, const double x); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"修正贝塞尔函数计算 // 第一类修正 int gsl_sf_bessel_I0_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_I0(const double x); int gsl_sf_bessel_I1_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_I1(const double x); int gsl_sf_bessel_In_e(const int n, const double x, gsl_sf_result * result); double gsl_sf_bessel_In(const int n, const double x); int gsl_sf_bessel_In_array(const int nmin, const int nmax, const double x, double * result_array); // 分数阶 int gsl_sf_bessel_Inu_e(double nu, double x, gsl_sf_result * result); double gsl_sf_bessel_Inu(double nu, double x); // 第一类修正 缩放 // exp(-|x|) I_0(x) int gsl_sf_bessel_I0_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_I0_scaled(const double x); // exp(-|x|) I_1(x) int gsl_sf_bessel_I1_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_I1_scaled(const double x); // exp(-|x|) I_n(x) int gsl_sf_bessel_In_scaled_e(int n, const double x, gsl_sf_result * result); double gsl_sf_bessel_In_scaled(const int n, const double x); int gsl_sf_bessel_In_scaled_array(const int nmin, const int nmax, const double x, double * result_array); // 分数阶 Exp[-|x|] BesselI[nu, x] x \u003e= 0, nu \u003e= 0 int gsl_sf_bessel_Inu_scaled_e(double nu, double x, gsl_sf_result * result); double gsl_sf_bessel_Inu_scaled(double nu, double x); // 第二类修正 // x \u003e 0.0 int gsl_sf_bessel_K0_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_K0(const double x); int gsl_sf_bessel_K1_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_K1(const double x); int gsl_sf_bessel_Kn_e(const int n, const double x, gsl_sf_result * result); double gsl_sf_bessel_Kn(const int n, const double x); int gsl_sf_bessel_Kn_array(const int nmin, const int nmax, const double x, double * result_array); // 分数阶 BesselK[nu, x] x \u003e 0, nu \u003e= 0 int gsl_sf_bessel_Knu_e(const double nu, const double x, gsl_sf_result * result); double gsl_sf_bessel_Knu(const double nu, const double x); // 自然对数，分数阶 ln[BesselK[nu, x]] x \u003e 0, nu \u003e= 0 int gsl_sf_bessel_lnKnu_e(const double nu, const double x, gsl_sf_result * result); double gsl_sf_bessel_lnKnu(const double nu, const double x); // 第二类修正 缩放 // exp(x) K_0(x) x \u003e 0.0 int gsl_sf_bessel_K0_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_K0_scaled(const double x); // exp(x) K_1(x) x \u003e 0.0 int gsl_sf_bessel_K1_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_K1_scaled(const double x); // exp(x) K_n(x) x \u003e 0.0 int gsl_sf_bessel_Kn_scaled_e(int n, const double x, gsl_sf_result * result); double gsl_sf_bessel_Kn_scaled(const int n, const double x); int gsl_sf_bessel_Kn_scaled_array(const int nmin, const int nmax, const double x, double * result_array); // 分数阶 Exp[+|x|] BesselK[nu, x] x \u003e 0, nu \u003e= 0 int gsl_sf_bessel_Knu_scaled_e(const double nu, const double x, gsl_sf_result * result); double gsl_sf_bessel_Knu_scaled(const double nu, const double x); int gsl_sf_bessel_Knu_scaled_e10_e(const double nu, const double x, gsl_sf_result_e10 * result); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:3","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"球贝塞尔函数计算 // 第一类 球 // j_0(x) = sin(x)/x int gsl_sf_bessel_j0_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_j0(const double x); // j_1(x) = (sin(x)/x - cos(x))/x int gsl_sf_bessel_j1_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_j1(const double x); // j_2(x) = ((3/x^2 - 1)sin(x) - 3cos(x)/x)/x int gsl_sf_bessel_j2_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_j2(const double x); // j_l(x) int gsl_sf_bessel_jl_e(const int l, const double x, gsl_sf_result * result); double gsl_sf_bessel_jl(const int l, const double x); // j_l(x) for l=0,1,...,lmax l \u003e= 0, x \u003e= 0.0 int gsl_sf_bessel_jl_array(const int lmax, const double x, double * result_array); // j_l(x) for l=0,1,...,lmax Uses Steed's method. int gsl_sf_bessel_jl_steed_array(const int lmax, const double x, double * jl_x_array); // 第二类 球 int gsl_sf_bessel_y0_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_y0(const double x); int gsl_sf_bessel_y1_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_y1(const double x); int gsl_sf_bessel_y2_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_y2(const double x); int gsl_sf_bessel_yl_e(int l, const double x, gsl_sf_result * result); double gsl_sf_bessel_yl(const int l, const double x); int gsl_sf_bessel_yl_array(const int lmax, const double x, double * result_array); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:4","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"修正球贝塞尔函数计算 // 第一类 修正球 缩放 // Exp[-|x|] i_0(x)，这里 i 代表第一类修正球 int gsl_sf_bessel_i0_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_i0_scaled(const double x); // Exp[-|x|] i_2(x) int gsl_sf_bessel_i2_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_i2_scaled(const double x); // Exp[-|x|] i_l(x) ，l \u003e= 0 // i_l(x) = Sqrt[Pi/(2x)] BesselI[l+1/2,x] 使用 第一类修正 计算 int gsl_sf_bessel_il_scaled_e(const int l, double x, gsl_sf_result * result); double gsl_sf_bessel_il_scaled(const int l, const double x); // Exp[-|x|] i_l(x) for l=0,1,...,lmax int gsl_sf_bessel_il_scaled_array(const int lmax, const double x, double * result_array); // 第二类 修正球 缩放 // Exp[x] k_0(x) x \u003e 0.0 int gsl_sf_bessel_k0_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_k0_scaled(const double x); // Exp[x] k_1(x) x \u003e 0.0 int gsl_sf_bessel_k1_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_k1_scaled(const double x); // Exp[x] k_2(x) x \u003e 0.0 int gsl_sf_bessel_k2_scaled_e(const double x, gsl_sf_result * result); double gsl_sf_bessel_k2_scaled(const double x); // Exp[x] k_l[x] k_l(x) = Sqrt[Pi/(2x)] BesselK[l+1/2,x] int gsl_sf_bessel_kl_scaled_e(int l, const double x, gsl_sf_result * result); double gsl_sf_bessel_kl_scaled(const int l, const double x); // Exp[x] k_l(x) for l=0,1,...,lmax int gsl_sf_bessel_kl_scaled_array(const int lmax, const double x, double * result_array); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:5","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"第一类贝塞尔函数的零点 // 第一类 0 阶 贝塞尔函数 的 第 s 个 正零点 int gsl_sf_bessel_zero_J0_e(unsigned int s, gsl_sf_result * result); double gsl_sf_bessel_zero_J0(unsigned int s); // 第一类 1 阶 贝塞尔函数 的 第 s 个 正零点 int gsl_sf_bessel_zero_J1_e(unsigned int s, gsl_sf_result * result); double gsl_sf_bessel_zero_J1(unsigned int s); // 第一类 nu 阶 贝塞尔函数 的 第 s 个 正零点 int gsl_sf_bessel_zero_Jnu_e(double nu, unsigned int s, gsl_sf_result * result); double gsl_sf_bessel_zero_Jnu(double nu, unsigned int s); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:3:6","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"4 参考 Milton Abramowitz and Irene A. Stegun, eds., Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables (Dover: New York, 1972) ↩︎ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/:4:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 3 — 贝塞尔 (Bessel) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B03/"},{"categories":["GSL"],"content":"GSL 特殊函数 2","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"1 写在前面 对以下变量参见：变量定义 gsl_sf_result * result gsl_mode_t mode ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:1:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"2 头文件 若无特别说明，本篇代码均来自头文件 gsl_sf_airy.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:2:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"3 艾里 (Airy) 函数和导数 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:3:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"基本介绍1 艾里方程（斯托克斯方程） $$y^{\\prime \\prime}-x y=0$$ 艾里函数 此方程有两个线性独立解： $$\\operatorname{Ai}(x)=\\frac{1}{\\pi} \\int_{0}^{\\infty} \\cos \\left(\\frac{t^{3}}{3}+x t\\right) d t$$ $$\\mathrm{Bi}(x)=\\frac{1}{\\pi} \\int_{0}^{\\infty} e^{\\left(-\\frac{t^{3}}{3}+x t\\right)}+\\sin \\left(\\frac{t^{3}}{3}+x t\\right) d t$$ 艾里函数正极限 当 $x$ 趋于正无穷， $$\\operatorname{Ai}(x) \\sim \\frac{e^{-\\frac{2}{3} x^{3 / 2}}}{2 \\sqrt{\\pi} x^{1 / 4}} $$ $$\\operatorname{Bi}(x) \\sim \\frac{e^{\\frac{2}{3} x^{3 / 2}}}{\\sqrt{\\pi} x^{1 / 4}}$$ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:3:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"计算函数 int gsl_sf_airy_Ai_e(const double x, const gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Ai(const double x, gsl_mode_t mode); int gsl_sf_airy_Bi_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Bi(const double x, gsl_mode_t mode); /* scaled Ai(x): * Ai(x) x \u003c 0 * exp(+2/3 x^{3/2}) Ai(x) x \u003e 0 * * exceptions: none */ int gsl_sf_airy_Ai_scaled_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Ai_scaled(const double x, gsl_mode_t mode); /* scaled Bi(x): * Bi(x) x \u003c 0 * exp(-2/3 x^{3/2}) Bi(x) x \u003e 0 * * exceptions: none */ int gsl_sf_airy_Bi_scaled_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Bi_scaled(const double x, gsl_mode_t mode); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:3:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"计算导数 int gsl_sf_airy_Ai_deriv_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Ai_deriv(const double x, gsl_mode_t mode); int gsl_sf_airy_Bi_deriv_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Bi_deriv(const double x, gsl_mode_t mode); /* scaled derivative Ai'(x): * Ai'(x) x \u003c 0 * exp(+2/3 x^{3/2}) Ai'(x) x \u003e 0 * * exceptions: none */ int gsl_sf_airy_Ai_deriv_scaled_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Ai_deriv_scaled(const double x, gsl_mode_t mode); /* scaled derivative: * Bi'(x) x \u003c 0 * exp(-2/3 x^{3/2}) Bi'(x) x \u003e 0 * * exceptions: none */ int gsl_sf_airy_Bi_deriv_scaled_e(const double x, gsl_mode_t mode, gsl_sf_result * result); double gsl_sf_airy_Bi_deriv_scaled(const double x, gsl_mode_t mode); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:3:3","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"计算零点 计算艾里函数的第 $s$ 个零点 /* Zeros of Ai(x) */ int gsl_sf_airy_zero_Ai_e(unsigned int s, gsl_sf_result * result); double gsl_sf_airy_zero_Ai(unsigned int s); /* Zeros of Bi(x) */ int gsl_sf_airy_zero_Bi_e(unsigned int s, gsl_sf_result * result); double gsl_sf_airy_zero_Bi(unsigned int s); 计算艾里函数导数的第 $s$ 个零点 /* Zeros of Ai'(x) */ int gsl_sf_airy_zero_Ai_deriv_e(unsigned int s, gsl_sf_result * result); double gsl_sf_airy_zero_Ai_deriv(unsigned int s); /* Zeros of Bi'(x) */ int gsl_sf_airy_zero_Bi_deriv_e(unsigned int s, gsl_sf_result * result); double gsl_sf_airy_zero_Bi_deriv(unsigned int s); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:3:4","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"4 参考 https://zh.wikipedia.org/wiki/%E8%89%BE%E9%87%8C%E5%87%BD%E6%95%B0 ↩︎ ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/:4:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 2 — 艾里 (Airy) 函数","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B02/"},{"categories":["GSL"],"content":"GSL 特殊函数 1","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 1 — 用法，结果类，模式","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/"},{"categories":["GSL"],"content":"1 用法，结果类，模式 ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/:1:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 1 — 用法，结果类，模式","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/"},{"categories":["GSL"],"content":"用法 正常调用，返回计算值 错误句柄形式调用，返回错误码 以 $0$ 阶第一类贝塞尔函数 $J_0(x)$ 计算为例说明： 正常调用： double y = gsl_sf_bessel_J0(x); 错误句柄形式调用： gsl_sf_result result; int status = gsl_sf_bessel_J0_e(x, \u0026result); ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/:1:1","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 1 — 用法，结果类，模式","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/"},{"categories":["GSL"],"content":"结果类 这里的 gsl_sf_result 类定义： // gsl_sf_result.h struct gsl_sf_result_struct { double val; double err; }; typedef struct gsl_sf_result_struct gsl_sf_result; 上述示例结果如下： 当结果溢出时，为了将结果保存，可以使用指数缩放。使用 gsl_sf_result_e10，定义为： // gsl_sf_result.h struct gsl_sf_result_e10_struct { double val; double err; int e10; }; typedef struct gsl_sf_result_e10_struct gsl_sf_result_e10; 这样，实际结果相应地变为 result.val * 10^(result.e10) ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/:1:2","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 1 — 用法，结果类，模式","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/"},{"categories":["GSL"],"content":"模式 gsl_mode_t: 模式类，用来控制精度，改变计算性能 定义： // gsl_mode.h // gsl_mode_t 就是个无符号整型 typedef unsigned int gsl_mode_t; // 0，1，2 对应不同的精度 #define GSL_PREC_DOUBLE 0 // 相对精度大约是 2 x 10^(-16) #define GSL_PREC_SINGLE 1 // 相对精度大约是 2 x 10^(-7) #define GSL_PREC_APPROX 2 // 相对精度大约是 5 x 10^(-4) ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/:1:3","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 1 — 用法，结果类，模式","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/"},{"categories":["GSL"],"content":"2 参考 https://www.gnu.org/software/gsl/doc/html/specfunc.htm ","date":"2020-05-09","objectID":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/:2:0","tags":["GSL","特殊函数"],"title":"GSL 系列 4 — 特殊函数 1 — 用法，结果类，模式","uri":"/2020/05/gsl%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B01/"},{"categories":["GSL"],"content":"GSL 多项式模块","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"1 头文件 gsl_poly.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:1:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"2 多项式计算 $$P(x)=c[0]+c[1] x+c[2] x^{2}+\\cdots+c[l e n-1] x^{l e n-1}$$ // gsl_poly.h /* real polynomial, real x */ INLINE_DECL double gsl_poly_eval(const double c[], const int len, const double x); /* real polynomial, complex x */ INLINE_DECL gsl_complex gsl_poly_complex_eval(const double c [], const int len, const gsl_complex z); /* complex polynomial, complex x */ INLINE_DECL gsl_complex gsl_complex_poly_complex_eval(const gsl_complex c [], const int len, const gsl_complex z); /* 计算多项式以及多项式的多阶导数，多阶导数的计算结果存在 res 数组中，从第 0 阶开始 */ int gsl_poly_eval_derivs(const double c[], const size_t lenc, const double x, double res[], const size_t lenres); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:2:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"3 差商计算 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:3:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"差商基本介绍 差商如何计算？ 给定 $n+1$ 个数据点（插值点），$(x_0, y_0),(x_2,y_2) \\cdots(x_n,y_n)$，那么就可以计算差商了 1。 差商有什么用？ 构建多项式 比如构建牛顿多项式，其利用差商可以表示为： $$N(x)=y_0+\\sum_{j=1}^{n} [y_0,y_1,\\cdots y_j] (x-x_0)(x-x_1)\\cdots(x-x_{j-1})$$ 可以看到，利用差商 $[y_0,y_1,\\cdots y_j]$，插值点的 $x$ 坐标，就可以构造出一个牛顿多项式。 也可以通过差商来构建厄密特多项式。 比如，对 $n+1$ 个插值点 $(x_0, y_0),(x_2,y_2) \\cdots(x_n,y_n)$，不仅插值多项式要过插值点，同时插值多项式也要满足一阶导数条件，利用差商，相应的厄密特多项式可以写为： 其中：$m_{2j}=m_{2j+1}=y_j,z_{2j}=z_{2j+1}=y_j$ 总结一下：通过差商配合插值点的横坐标就可以构造出多项式了。其实就是多项式的差商表述形式。 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:3:1","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"差商计算函数 // gsl_poly.h /* dd 差商数组，x 插值点横坐标数值，y 插值点横坐标数组，size 插值点数 根据 x, y 计算差商储存在 dd 中 */ int gsl_poly_dd_init(double dd[], const double x[], const double y[], size_t size); /* 根据 dd, xa 构造的多项式，计算在点 x 处的值 内联（ifdef HAVE_INLINE） */ INLINE_DECL double gsl_poly_dd_eval(const double dd[], const double xa[], const size_t size, const double x); /* c 泰勒系数，xp 泰勒展开点，w 为工作空间，长度为 size 根据 dd, x 构造的多项式在点 xp 进行泰勒展开，泰勒系数存在 c 中 */ int gsl_poly_dd_taylor(double c[], double xp, const double dd[], const double x[], size_t size, double w[]); /* z 厄密特（一阶导条件）插值多项式的等效插值点横坐标数组，dd 厄密特差商数组 dya 一阶导条件，长度为 size 根据插值点 xa, ya, 一阶导条件 dya，计算厄密特多项式的差商和等效插值点横坐标，存储在 dd 和 z 中 */ int gsl_poly_dd_hermite_init(double dd[], double z[], const double xa[], const double ya[], const double dya[], const size_t size); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:3:2","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"4 二次方程 $$a x^{2}+b x+c=0$$ // gsl_poly.h /*计算实根，无根时，x0,x1 不变，一个根 x0, 两个根 x0, x1 升序*/ int gsl_poly_solve_quadratic(double a, double b, double c, double * x0, double * x1); $$a z^{2}+b z+c=0$$ // gsl_poly.h /*一个根 z0, 两个根 z0, z1 升序，先按实部，再按虚部*/ int gsl_poly_complex_solve_quadratic(double a, double b, double c, gsl_complex * z0, gsl_complex * z1); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:4:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"5 三次方程 // gsl_poly.h int gsl_poly_solve_cubic(double a, double b, double c, double * x0, double * x1, double * x2); int gsl_poly_complex_solve_cubic(double a, double b, double c, gsl_complex * z0, gsl_complex * z1, gsl_complex * z2); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:5:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"6 一般多项式方程 使用迭代的方法寻根 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:6:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"工作空间 多项式复工作空间类 gsl_poly_complex_workspace 定义： // gsl_poly.h typedef struct { size_t nc ; double * matrix ; } gsl_poly_complex_workspace ; // vcruntime.h #ifdef _WIN64 typedef unsigned __int64 size_t; typedef __int64 ptrdiff_t; typedef __int64 intptr_t; #else typedef unsigned int size_t; typedef int ptrdiff_t; typedef int intptr_t; #endif 多项式复工作空间 分配和清理 // gsl_poly.h // n 多项式的系数个数 // 返回一个工作空间指针 gsl_poly_complex_workspace * gsl_poly_complex_workspace_alloc(size_t n); // 清理工作空间，根据工作空间指针 w void gsl_poly_complex_workspace_free(gsl_poly_complex_workspace * w); ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:6:1","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"求解 $$P(x)=a_{0}+a_{1} x+a_{2} x^{2}+\\cdots+a_{n-1} x^{n-1}$$ // gsl_poly.h /* n 系数数组长度，最高阶系数要求非0 将 n-1 个复根，存在 z 中, z 为 double 指针，指向长度为 2n-2 的数组 如果找到根，返回 GSL_SUCCESS */ int gsl_poly_complex_solve (const double * a, size_t n, gsl_poly_complex_workspace * w, gsl_complex_packed_ptr z); // gsl_complex.h typedef double * gsl_complex_packed_ptr ; ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:6:2","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"程序实例 计算：$P(x)=x^{5}-1$ #include \u003cstdio.h\u003e #include \u003cgsl/gsl_poly.h\u003e int main(void) { int i; /* coefficients of P(x) = -1 + x^5 */ double a[6] = { -1, 0, 0, 0, 0, 1 }; double z[10]; // 因为是复根，所以是 2x5=10 gsl_poly_complex_workspace* w = gsl_poly_complex_workspace_alloc(6); gsl_poly_complex_solve(a, 6, w, z); gsl_poly_complex_workspace_free(w); for (i = 0; i \u003c 5; i++) { printf(\"z%d = %+.18f %+.18f i\\n\", i, z[2 * i], z[2 * i + 1]); } return 0; } ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:6:3","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"7 引用和参考 https://www.gnu.org/software/gsl/doc/html/poly.html https://baike.baidu.com/item/%E5%B7%AE%E5%95%86 ↩︎ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/:7:0","tags":["GSL","多项式"],"title":"GSL 系列 3 — 多项式","uri":"/2020/05/gsl%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"categories":["GSL"],"content":"GSL 复数模块","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"1 头文件 gsl_complex.h: 定义复数类 gsl_complex_math.h: 定义复函数和相关运算 ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:1:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"2 复数表示 gsl_complex 类定义： // gsl_complex.h typedef struct { double dat[2]; } gsl_complex; 复数实部：dat[0] 复数虚部：dat[1] ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:2:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"复数构建函数 gsl_complex_polar: 从极坐标构建 gsl_complex_rect: 从笛卡尔坐标构建，使用内联（当 HAVE_INLINE 定义时） gsl_complex gsl_complex_polar (double r, double theta); /* r= r e^(i theta) */ INLINE_DECL gsl_complex gsl_complex_rect (double x, double y); /* r= real+i*imag */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:2:1","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"复数基本操作宏 GSL_REAL(z): 获取复数 z 的实部 GSL_IMAG(z): 获取复数 z 的虚部 GSL_COMPLEX_P(zp): 获取指针 zp 所指的复数 GSL_COMPLEX_P_REAL(zp): 获取指针 zp 所指的复数实部 GSL_COMPLEX_P_IMAG(zp): 获取指针 zp 所指的复数虚部 GSL_COMPLEX_EQ(z1,z2): 判断两个复数是否相等 GSL_SET_COMPLEX(zp, x, y): 通过复数指针 zp，以笛卡尔坐标形式设定复数 GSL_SET_REAL(zp, x): 通过复数指针 zp，设定复数实部 GSL_SET_IMAG(zp, y): 通过复数指针 zp，设定复数虚部 宏定义： // gsl_complex.h #define GSL_REAL(z) ((z).dat[0]) #define GSL_IMAG(z) ((z).dat[1]) #define GSL_COMPLEX_P(zp) ((zp)-\u003edat) #define GSL_COMPLEX_P_REAL(zp) ((zp)-\u003edat[0]) #define GSL_COMPLEX_P_IMAG(zp) ((zp)-\u003edat[1]) #define GSL_COMPLEX_EQ(z1,z2) (((z1).dat[0] == (z2).dat[0]) \u0026\u0026 ((z1).dat[1] == (z2).dat[1])) ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:2:2","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"3 复数属性获取函数 // gsl_complex_math.h double gsl_complex_arg(gsl_complex z); /* return arg(z), -pi\u003c arg(z) \u003c=+pi */ double gsl_complex_abs(gsl_complex z); /* return |z| */ double gsl_complex_abs2(gsl_complex z); /* return |z|^2 */ double gsl_complex_logabs(gsl_complex z); /* return log|z| */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:3:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"4 复数算术运算 // gsl_complex_math.h gsl_complex gsl_complex_add(gsl_complex a, gsl_complex b); /* r=a+b */ gsl_complex gsl_complex_sub(gsl_complex a, gsl_complex b); /* r=a-b */ gsl_complex gsl_complex_mul(gsl_complex a, gsl_complex b); /* r=a*b */ gsl_complex gsl_complex_div(gsl_complex a, gsl_complex b); /* r=a/b */ gsl_complex gsl_complex_add_real(gsl_complex a, double x); /* r=a+x */ gsl_complex gsl_complex_sub_real(gsl_complex a, double x); /* r=a-x */ gsl_complex gsl_complex_mul_real(gsl_complex a, double x); /* r=a*x */ gsl_complex gsl_complex_div_real(gsl_complex a, double x); /* r=a/x */ gsl_complex gsl_complex_add_imag(gsl_complex a, double y); /* r=a+iy */ gsl_complex gsl_complex_sub_imag(gsl_complex a, double y); /* r=a-iy */ gsl_complex gsl_complex_mul_imag(gsl_complex a, double y); /* r=a*iy */ gsl_complex gsl_complex_div_imag(gsl_complex a, double y); /* r=a/iy */ gsl_complex gsl_complex_conjugate(gsl_complex z); /* r=conj(z) * 共轭/ gsl_complex gsl_complex_inverse(gsl_complex a); /* r=1/a * 逆/ gsl_complex gsl_complex_negative(gsl_complex a); /* r=-a * 相反/ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:4:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"5 初等复函数 // gsl_complex_math.h gsl_complex gsl_complex_sqrt(gsl_complex z); /* r=sqrt(z) */ gsl_complex gsl_complex_sqrt_real(double x); /* r=sqrt(x) (x\u003c0 ok) */ gsl_complex gsl_complex_pow(gsl_complex a, gsl_complex b); /* r=a^b */ gsl_complex gsl_complex_pow_real(gsl_complex a, double b); /* r=a^b */ gsl_complex gsl_complex_exp(gsl_complex a); /* r=exp(a) */ gsl_complex gsl_complex_log(gsl_complex a); /* r=log(a) (base e) */ gsl_complex gsl_complex_log10(gsl_complex a); /* r=log10(a) (base 10) */ gsl_complex gsl_complex_log_b(gsl_complex a, gsl_complex b); /* r=log_b(a) (base=b) */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:5:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"6 复三角函数 // gsl_complex_math.h gsl_complex gsl_complex_sin(gsl_complex a); /* r=sin(a) */ gsl_complex gsl_complex_cos(gsl_complex a); /* r=cos(a) */ gsl_complex gsl_complex_sec(gsl_complex a); /* r=sec(a) */ gsl_complex gsl_complex_csc(gsl_complex a); /* r=csc(a) */ gsl_complex gsl_complex_tan(gsl_complex a); /* r=tan(a) */ gsl_complex gsl_complex_cot(gsl_complex a); /* r=cot(a) */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:6:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"7 复反三角函数 // gsl_complex_math.h gsl_complex gsl_complex_arcsin(gsl_complex a); /* r=arcsin(a) */ gsl_complex gsl_complex_arcsin_real(double a); /* r=arcsin(a) */ gsl_complex gsl_complex_arccos(gsl_complex a); /* r=arccos(a) */ gsl_complex gsl_complex_arccos_real(double a); /* r=arccos(a) */ gsl_complex gsl_complex_arcsec(gsl_complex a); /* r=arcsec(a) */ gsl_complex gsl_complex_arcsec_real(double a); /* r=arcsec(a) */ gsl_complex gsl_complex_arccsc(gsl_complex a); /* r=arccsc(a) */ gsl_complex gsl_complex_arccsc_real(double a); /* r=arccsc(a) */ gsl_complex gsl_complex_arctan(gsl_complex a); /* r=arctan(a) */ gsl_complex gsl_complex_arccot(gsl_complex a); /* r=arccot(a) */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:7:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"8 复双曲函数 // gsl_complex_math.h gsl_complex gsl_complex_sinh(gsl_complex a); /* r=sinh(a) */ gsl_complex gsl_complex_cosh(gsl_complex a); /* r=coshh(a) */ gsl_complex gsl_complex_sech(gsl_complex a); /* r=sech(a) */ gsl_complex gsl_complex_csch(gsl_complex a); /* r=csch(a) */ gsl_complex gsl_complex_tanh(gsl_complex a); /* r=tanh(a) */ gsl_complex gsl_complex_coth(gsl_complex a); /* r=coth(a) */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:8:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"9 复反双曲函数 // gsl_complex_math.h gsl_complex gsl_complex_arcsinh(gsl_complex a); /* r=arcsinh(a) */ gsl_complex gsl_complex_arccosh(gsl_complex a); /* r=arccosh(a) */ gsl_complex gsl_complex_arccosh_real(double a); /* r=arccosh(a) */ gsl_complex gsl_complex_arcsech(gsl_complex a); /* r=arcsech(a) */ gsl_complex gsl_complex_arccsch(gsl_complex a); /* r=arccsch(a) */ gsl_complex gsl_complex_arctanh(gsl_complex a); /* r=arctanh(a) */ gsl_complex gsl_complex_arctanh_real(double a); /* r=arctanh(a) */ gsl_complex gsl_complex_arccoth(gsl_complex a); /* r=arccoth(a) */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:9:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"10 参考 https://www.gnu.org/software/gsl/doc/html/complex.html ","date":"2020-05-09","objectID":"/2020/05/gsl%E5%A4%8D%E6%95%B0/:10:0","tags":["GSL","复数"],"title":"GSL 系列 2 — 复数","uri":"/2020/05/gsl%E5%A4%8D%E6%95%B0/"},{"categories":["GSL"],"content":"GSL 数学函数模块","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"1 头文件 gsl_math.h ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:1:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"2 数学常量 宏定义示例： #ifndef M_E #define M_E 2.71828182845904523536028747135 /* e */ #endif ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:2:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"3 无穷和非数 GSL_POSINF: 正无穷 GSL_NEGINF: 负无穷 GSL_NAN：非数 宏定义： // gsl_nan.h #ifdef INFINITY # define GSL_POSINF INFINITY # define GSL_NEGINF (-INFINITY) #elif defined(HUGE_VAL) # define GSL_POSINF HUGE_VAL # define GSL_NEGINF (-HUGE_VAL) #else # define GSL_POSINF (gsl_posinf()) # define GSL_NEGINF (gsl_neginf()) #endif #ifdef NAN # define GSL_NAN NAN #elif defined(INFINITY) # define GSL_NAN (INFINITY/INFINITY) #else # define GSL_NAN (gsl_nan()) #endif //corecrt_math.h #ifndef _HUGE_ENUF #define _HUGE_ENUF 1e+300 // _HUGE_ENUF*_HUGE_ENUF must overflow #endif #define INFINITY ((float)(_HUGE_ENUF * _HUGE_ENUF)) #define HUGE_VAL ((double)INFINITY) #define NAN ((float)(INFINITY * 0.0F)) //gsl_sys.h double gsl_nan (void); double gsl_posinf (void); double gsl_neginf (void); 判断函数： //gsl_sys.h int gsl_isnan (const double x); //非数返回 1 int gsl_isinf (const double x); //正无穷返回 1，负无穷返回 -1，其他返回 0 int gsl_finite (const double x); // 实数返回 1，无穷和非数返回 0 ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:3:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"4 初等函数 // gsl_sys.h double gsl_log1p(const double x); // log(1+x); x 小的时候较为精确 double gsl_expm1(const double x); // exp(x)-1; x 小的时候较为精确 double gsl_hypot(const double x, const double y); // sqrt(x^2 + y^2); 避免溢出 double gsl_hypot3(const double x, const double y, const double z); // sqrt(x^2+y^2+z^2); 避免溢出 double gsl_acosh(const double x); // arccosh(x) double gsl_asinh(const double x); // arcsinh(x) double gsl_atanh(const double x); // arctanh(x) double gsl_ldexp(const double x, const int e); // x*2^e; double gsl_frexp(const double x, int * e); // x/2^e; x为0，f,e 都设为 0 ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:4:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"5 小整数幂 // gsl_pow_int.h INLINE_DECL double gsl_pow_2(const double x); INLINE_DECL double gsl_pow_3(const double x); INLINE_DECL double gsl_pow_4(const double x); INLINE_DECL double gsl_pow_5(const double x); INLINE_DECL double gsl_pow_6(const double x); INLINE_DECL double gsl_pow_7(const double x); INLINE_DECL double gsl_pow_8(const double x); INLINE_DECL double gsl_pow_9(const double x); /* HAVE_INLINE被定义时，以上函数使用内联 */ double gsl_pow_int(double x, int n); double gsl_pow_uint(double x, unsigned int n); /* 该函数还有另一个版本，会计算数值误差，gsl_sf_pow_int_e() ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:5:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"6 正负测试 GSL_SIGN(X): 大于等于 0 为 1，小于 0 为 -1 宏定义： // gsl_math.h #define GSL_SIGN(x) ((x) \u003e= 0.0 ? 1 : -1) ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:6:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"7 奇偶数测试 GSL_IS_ODD(n): 奇数返回 1，偶数返回 0 GSL_IS_EVEN(n): 偶数返回 1，奇数返回 0 宏定义： // gsl_math.h #define GSL_IS_ODD(n) ((n) \u0026 1) #define GSL_IS_EVEN(n) (!(GSL_IS_ODD(n))) ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:7:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"8 最大最小函数 GSL_MAX(a,b): 返回 a, b 的最大值 GSL_MIN(a,b): 返回 a, b 的最小值 宏定义： // gsl_minmax.h #define GSL_MAX(a,b) ((a) \u003e (b) ? (a) : (b)) #define GSL_MIN(a,b) ((a) \u003c (b) ? (a) : (b)) // 以上两个宏，还有函数版本 gsl_max, gsl_min double gsl_max (double a, double b); double gsl_min (double a, double b); 内联函数版本(HAVE_INLINE 定义的前提下)： // gsl_minmax.h INLINE_FUN int GSL_MAX_INT (int a, int b); INLINE_FUN int GSL_MIN_INT (int a, int b); INLINE_FUN double GSL_MAX_DBL (double a, double b); INLINE_FUN double GSL_MIN_DBL (double a, double b); INLINE_FUN long double GSL_MAX_LDBL (long double a, long double b); INLINE_FUN long double GSL_MIN_LDBL (long double a, long double b); // 内联版本实现示例 INLINE_FUN int GSL_MAX_INT (int a, int b) { return GSL_MAX (a, b); } //无内联版本 #define GSL_MAX_INT(a,b) GSL_MAX(a,b) ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:8:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"9 浮点数的近似比较 int gsl_fcmp (const double x1, const double x2, const double epsilon); /* 判断 x, y 是否近似等于一个相对精度 epsilon, 根据 frexp() 计算出一个间隔, 判断 x, y 是否在间隔之内， 在，即返回0，认为近似相等，否则，x \u003c y 返回 -1，x \u003e y 返回 + 1。 注意，比较的是相对精度，而不是两者间隔接近 0 的程度。 基于 fcmp 实现。 */ ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:9:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["GSL"],"content":"10 参考 https://www.gnu.org/software/gsl/doc/html/math.html ","date":"2020-05-09","objectID":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/:10:0","tags":["GSL"],"title":"GSL 系列 1 — 数学函数","uri":"/2020/05/gsl%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"categories":["Windows"],"content":"使用 windows terminal 后，GitBash 终端里中文乱码问题的解决","date":"2020-05-09","objectID":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","tags":["windows","gitbash","vim"],"title":"windows系统 Git Bash 中文乱码问题解决","uri":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"categories":["Windows"],"content":"1 Windows系统和Git 版本 windows 10 v 1909 Git version 2.62 ","date":"2020-05-09","objectID":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/:1:0","tags":["windows","gitbash","vim"],"title":"windows系统 Git Bash 中文乱码问题解决","uri":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"categories":["Windows"],"content":"2 中文乱码问题 运行 \"%GIT_HOME%\\git-bash.exe\" 未发现中文乱码问题，中文乱码主要来源于运行 \"%GIT_HOME%\\bin\\bash.exe\" 乱码表现主要发现来自于四个方面： git 相关显示的中文乱码 中文输入的乱码 vi 编辑器的中文乱码 运行一些 bash 命令时（如 ls），出现乱码 ","date":"2020-05-09","objectID":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/:2:0","tags":["windows","gitbash","vim"],"title":"windows系统 Git Bash 中文乱码问题解决","uri":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"categories":["Windows"],"content":"3 解决方案 修改配置文件 gitconfig 文件，路径 \"%GIT_HOME%\\etc\\gitconfig\"，添加如下项 [core] quotepath = off [gui] encoding = utf-8 [i18n] commitencoding = utf-8 logoutputencoding = utf-8 inputrc 文件，路径 \"%GIT_HOME%\\etc\\inputrc\"，修改如下项 # disable/enable 8bit input set input-meta off set output-meta on set convert-meta off vimrc 文件，路径 \"%GIT_HOME%\\etc\\vimrc\"， 添加如下项 set encoding=utf-8 .bashrc 文件，路径 %USERPROFILE%\\.bashrc，(没有就自己创建)，添加如下项 export LESSCHARSET=utf-8 # 配合 gitconfig 文件，解决 git 相关乱码问题 export LANG=\"C.UTF-8\" ","date":"2020-05-09","objectID":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/:3:0","tags":["windows","gitbash","vim"],"title":"windows系统 Git Bash 中文乱码问题解决","uri":"/2020/05/win10%E7%9A%84gitbash%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"categories":["Python"],"content":"在 Windows 平台上，利用 Visual Studio 2019 和 Anaconda3 编写 Python 的 C++ 拓展，包含相关配置和基本编写示例","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"1 测试环境 VC 2019 安装 “使用C++的桌面开发工作负载”，如下图 Anaconda3 64 位系统 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:1:0","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"2 拓展模块目标 C++ 实现基本的加减乘除函数，Python 进行调用 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:2:0","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"3 具体步骤 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:0","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"一、创建 DLL 项目 在 VC 2019 中创建一个 动态链接库(DLL) 解决方案 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:1","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"二、项目命名 项目名称 MyMath，创建，自动生成如下文件，解决方案资源管理器界面如下 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:2","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"三、项目属性设置 设置项目属性，分别是 附加包含目录（C/C++ → 常规）；附加库目录（链接器 → 常规）；附加依赖项（链接器 → 输入），三项的值分别添加如下路径或参数： 路径参数\r附加包含目录：%ANACONDA_HOME%\\include 附加库目录：%ANACONDA_HOME%\\libs 附加依赖项：python37.lib （%ANACONDA_HOME% 替换为 anaconda3 安装的根目录） ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:3","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"四、源文件编写 添加源文件 MyMath.cpp，如下 // MyMath.cpp #include \"pch.h\" #include \"Python.h\" double Add(double x, double y) { return x + y; } double Subtract(double x, double y) { return x - y; } double Multiply(double x, double y) { return x * y; } double Divide(double x, double y) { return x / y; } // 封装c++函数 PyObject* MyMath_Add(PyObject* self, PyObject* args) { double x, y; if (!PyArg_ParseTuple(args, \"dd\", \u0026x, \u0026y)) { return NULL; } return Py_BuildValue(\"d\", Add(x, y)); } PyObject* MyMath_Subtract(PyObject* self, PyObject* args) { double x, y; if (!PyArg_ParseTuple(args, \"dd\", \u0026x, \u0026y)) { return NULL; } return Py_BuildValue(\"d\", Subtract(x, y)); } PyObject* MyMath_Multiply(PyObject* self, PyObject* args) { double x, y; if (!PyArg_ParseTuple(args, \"dd\", \u0026x, \u0026y)) { return NULL; } return Py_BuildValue(\"d\", Multiply(x, y)); } PyObject* MyMath_Divide(PyObject* self, PyObject* args) { double x, y; if (!PyArg_ParseTuple(args, \"dd\", \u0026x, \u0026y)) { return NULL; } return Py_BuildValue(\"d\", Divide(x, y)); } static PyMethodDef MyMath_methods[] = { {\"add\", MyMath_Add, METH_VARARGS, \"This is an add function.\"}, {\"subtract\", MyMath_Subtract, METH_VARARGS, \"This is a subtract function.\"}, {\"multiply\", MyMath_Multiply, METH_VARARGS, \"This is a multiply function.\"}, {\"divide\", MyMath_Divide, METH_VARARGS, \"This is a divide function.\"}, {NULL, NULL, 0, NULL} }; static PyModuleDef MyMath_module = { PyModuleDef_HEAD_INIT, \"MyMath\", \"My Math Module\", 0, MyMath_methods }; PyMODINIT_FUNC PyInit_MyMath() { return PyModule_Create(\u0026MyMath_module); } ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:4","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"五、配置和生成解决方案 选择 解决方案配置和平台， 如下，然后生成解决方案 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:5","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"六、构建 python 测试项目 在生成目录中找到生成的 MyMath.dll 文件，移动到 python 项目下，并把后缀改为 .pyd，python 目录结构如下 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:6","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"七、测试结果 测试代码 ## main.py import MyMath print(MyMath.add(1.5, 3.)) print(MyMath.subtract(1.5, 3.)) print(MyMath.multiply(1.5, 3.)) print(MyMath.divide(1.5, 3.)) print(type(MyMath.add(1.5, 3.))) 运行结果： ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:3:7","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["Python"],"content":"4 参考 https://docs.python.org/zh-cn/3/extending/extending.html https://docs.microsoft.com/zh-cn/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2019 ","date":"2020-05-09","objectID":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/:4:0","tags":["VC 2019","python","C++"],"title":"Windows 系统 使用 VC2019 编写 python 的 C++ 拓展","uri":"/2020/05/windows%E4%BD%BF%E7%94%A8vc2019%E7%BC%96%E5%86%99python%E7%9A%84c-%E6%8B%93%E5%B1%95/"},{"categories":["LaTex"],"content":"利用 inkscape 在 latex 中插入 svg 格式图片","date":"2020-05-09","objectID":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/","tags":["inkscape","svg","Latex"],"title":"Latex 插入 svg 图片","uri":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/"},{"categories":["LaTex"],"content":"1 前提 以下几种方法均是基于对 inkscape 的调用，因此需要设置 inkscape 在环境变量中 可在命令行中输入 inkscape -V 进行测试是否设置成功 ","date":"2020-05-09","objectID":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/:1:0","tags":["inkscape","svg","Latex"],"title":"Latex 插入 svg 图片","uri":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/"},{"categories":["LaTex"],"content":"2 方法一 使用 svg 宏包 导言区： \\usepackage{svg} \\svgsetup{ inkscapepath=i/svg-inkscape/ } \\svgpath{{svg/}} 正文区： \\includesvg{demo} 注意： 编译开启 \\write18, 即编译时需要加上 -shell-escape 参数 更多选项参数参见 svg 宏包文档 此方法对于 inkscape 1.0 已经失效 ","date":"2020-05-09","objectID":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/:2:0","tags":["inkscape","svg","Latex"],"title":"Latex 插入 svg 图片","uri":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/"},{"categories":["LaTex"],"content":"3 方法二 先利用 inkscape 导出 .pdf 和 .pdf_tex 文件，然后在 latex 文档中插入，注意文件名不要有空格 导出 .pdf 和 .pdf_tex 文件，在 cmd 中 执行 ## inkscape version 为 1.0 inkscape -D --export-type=pdf --export-latex demo.svg Latex 导言区 \\usepackage{color} \\usepackage{transparent} \\usepackage{graphicx} \\usepackage{import} \\newcommand{\\includesvg}[2]{% \\def\\svgwidth{#1}% \\import{i}{#2.pdf_tex}% } 正文区 \\begin{figure} \\centering \\includesvg{0.8\\columnwidth}{demo} \\caption{Figure} \\end{figure} ","date":"2020-05-09","objectID":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/:3:0","tags":["inkscape","svg","Latex"],"title":"Latex 插入 svg 图片","uri":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/"},{"categories":["LaTex"],"content":"4 方法三 利用 latex 调用 inkscape (version = 1.0) 导言区： \\usepackage{color} \\usepackage{transparent} \\usepackage{graphicx} \\usepackage{import} %% 注意图片途径为子目录 i \\newcommand{\\executeiffilenewer}[3]{% \\ifnum\\pdfstrcmp{\\pdffilemoddate{#1}}% {\\pdffilemoddate{#2}}\u003e0% {\\immediate\\write18{#3}}\\fi% } \\newcommand{\\includesvg}[2]{% \\executeiffilenewer{i/#2.svg}{i/#2.pdf}% {inkscape -D --export-filename=i/#2.pdf % --export-latex i/#2.svg}% \\def\\svgwidth{#1}% \\import{i}{#2.pdf_tex}%i } 正文区： \\begin{figure} \\centering \\includesvg{0.8\\columnwidth}{demo} \\caption{Figure} \\end{figure} 注意：需开启 \\write18, 即编译时需要加上 -shell-escape 参数 ","date":"2020-05-09","objectID":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/:4:0","tags":["inkscape","svg","Latex"],"title":"Latex 插入 svg 图片","uri":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/"},{"categories":["LaTex"],"content":"5 方法四 同样是利用 latex 调用 inkscape (version = 1.0) 完成 svg 到 pdf 的转化，但是不需要 latex 的文字处理 导言区： \\usepackage{graphicx} \\graphicspath{{i/}} \\newcommand{\\executeiffilenewer}[3]{% \\ifnum\\pdfstrcmp{\\pdffilemoddate{#1}}% {\\pdffilemoddate{#2}}\u003e0% {\\immediate\\write18{#3}}\\fi% } \\newcommand{\\includesvg}[2]{% \\executeiffilenewer{i/#2.svg}{i/#2.pdf}% {inkscape -D --export-filename=i/#2.pdf i/#2.svg}% \\includegraphics[width=#1]{#2.pdf}% } 正文区： \\begin{figure} \\centering \\includesvg{0.8\\columnwidth}{demo} \\caption{Figure} \\end{figure} 注意：需开启 \\write18, 即编译时需要加上 -shell-escape 参数 ","date":"2020-05-09","objectID":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/:5:0","tags":["inkscape","svg","Latex"],"title":"Latex 插入 svg 图片","uri":"/2020/05/latex%E6%8F%92%E5%85%A5svg%E5%9B%BE%E7%89%87/"},{"categories":null,"content":"问路的人。 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于自己","uri":"/about/"}]